diff -r -N -c a/dwarf.h b/dwarf.h
*** a/dwarf.h	2022-08-18 09:34:36.000000000 +0000
--- b/dwarf.h	2023-02-02 08:46:07.848178670 +0000
***************
*** 654,660 ****
      DW_DS_leading_overpunch = 2,
      DW_DS_trailing_overpunch = 3,
      DW_DS_leading_separate = 4,
!     DW_DS_trailing_separate = 5,
    };
  
  
--- 654,660 ----
      DW_DS_leading_overpunch = 2,
      DW_DS_trailing_overpunch = 3,
      DW_DS_leading_separate = 4,
!     DW_DS_trailing_separate = 5
    };
  
  
***************
*** 944,950 ****
      DW_SECT_LOCLISTS = 5,
      DW_SECT_STR_OFFSETS = 6,
      DW_SECT_MACRO = 7,
!     DW_SECT_RNGLISTS = 8,
    };
  
  
--- 944,950 ----
      DW_SECT_LOCLISTS = 5,
      DW_SECT_STR_OFFSETS = 6,
      DW_SECT_MACRO = 7,
!     DW_SECT_RNGLISTS = 8
    };
  
  
diff -r -N -c a/i386-asm.c b/i386-asm.c
*** a/i386-asm.c	2022-08-18 09:34:36.000000000 +0000
--- b/i386-asm.c	2023-02-02 09:41:56.785854363 +0000
***************
*** 221,245 ****
   0x65  /* gs */
  };
  
! static const ASMInstr asm_instrs[] = {
  #define ALT(x) x
  /* This removes a 0x0f in the second byte */
  #define O(o) ((uint64_t) ((((o) & 0xff00) == 0x0f00) ? ((((o) >> 8) & ~0xff) | ((o) & 0xff)) : (o)))
  /* This constructs instr_type from opcode, type and group.  */
  #define T(o,i,g) ((i) | ((g) << OPC_GROUP_SHIFT) | ((((o) & 0xff00) == 0x0f00) ? OPC_0F : 0))
  #define DEF_ASM_OP0(name, opcode)
! #define DEF_ASM_OP0L(name, opcode, group, instr_type) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 0, { 0 } },
! #define DEF_ASM_OP1(name, opcode, group, instr_type, op0) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 1, { op0 }},
! #define DEF_ASM_OP2(name, opcode, group, instr_type, op0, op1) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 2, { op0, op1 }},
! #define DEF_ASM_OP3(name, opcode, group, instr_type, op0, op1, op2) { TOK_ASM_ ## name, O(opcode), T(opcode, instr_type, group), 3, { op0, op1, op2 }},
  #ifdef TCC_TARGET_X86_64
  # include "x86_64-asm.h"
  #else
  # include "i386-asm.h"
  #endif
      /* last operation */
!     { 0, },
! };
  
  static const uint16_t op0_codes[] = {
  #define ALT(x)
--- 221,265 ----
   0x65  /* gs */
  };
  
! #ifdef TCC_TARGET_X86_64
! # include "x86_64-asm.h"
! #define NUM_ASM_INSTRS 10000 /* must correspond to the contents of x86_64-asm.h */
! #else
! #define NUM_ASM_INSTRS 306 /* must correspond to the contents of i386-asm.h */
! #endif
! static ASMInstr asm_instrs[NUM_ASM_INSTRS];
! 
! void fill_asm_instrs(){
!   int i;
!   ASMInstr *a = asm_instrs;
  #define ALT(x) x
  /* This removes a 0x0f in the second byte */
  #define O(o) ((uint64_t) ((((o) & 0xff00) == 0x0f00) ? ((((o) >> 8) & ~0xff) | ((o) & 0xff)) : (o)))
  /* This constructs instr_type from opcode, type and group.  */
  #define T(o,i,g) ((i) | ((g) << OPC_GROUP_SHIFT) | ((((o) & 0xff00) == 0x0f00) ? OPC_0F : 0))
  #define DEF_ASM_OP0(name, opcode)
! #define DEF_ASM_OP0L(name, Xopcode, group, Xinstr_type)  \
! a->sym = TOK_ASM_ ## name; a->opcode = O(Xopcode); a->instr_type = T(Xopcode, Xinstr_type, group); \
! a->nb_ops = 0; ++a;
! #define DEF_ASM_OP1(name, Xopcode, group, Xinstr_type, op0) \
! a->sym = TOK_ASM_ ## name; a->opcode = O(Xopcode); a->instr_type = T(Xopcode, Xinstr_type, group); \
! a->nb_ops = 1; a->op_type[0] = op0; ++a;
! #define DEF_ASM_OP2(name, Xopcode, group, Xinstr_type, op0, op1) \
! a->sym = TOK_ASM_ ## name; a->opcode = O(Xopcode); a->instr_type = T(Xopcode, Xinstr_type, group); \
! a->nb_ops = 2; a->op_type[0] = op0; a->op_type[1] = op1; ++a;
! #define DEF_ASM_OP3(name, Xopcode, group, Xinstr_type, op0, op1, op2) \
! a->sym = TOK_ASM_ ## name; a->opcode = O(Xopcode); a->instr_type = T(Xopcode, Xinstr_type, group); \
! a->nb_ops = 3; a->op_type[0] = op0; a->op_type[1] = op1; a->op_type[2] = op2; ++a;
  #ifdef TCC_TARGET_X86_64
  # include "x86_64-asm.h"
  #else
  # include "i386-asm.h"
  #endif
      /* last operation */
! a->sym = 0; ++a;
! /*  fprintf(stderr, "using %d slots of asm_instrs[]\n", a-asm_instrs); fflush(stderr); */
!   /* assert(a-asm_instrs == NUM_ASM_INSTRS); */
! }
  
  static const uint16_t op0_codes[] = {
  #define ALT(x)
***************
*** 658,677 ****
          memset(freq, 0, sizeof(freq));
          for(pa = asm_instrs; pa->sym != 0; pa++) {
              freq[pa->nb_ops]++;
!             //for(i=0;i<pa->nb_ops;i++) {
                  for(j=0;j<nb_op_vals;j++) {
!                     //if (pa->op_type[i] == op_vals[j])
                      if (pa->instr_type == op_vals[j])
                          goto found;
                  }
!                 //op_vals[nb_op_vals++] = pa->op_type[i];
                  op_vals[nb_op_vals++] = pa->instr_type;
              found: ;
!             //}
          }
          for(i=0;i<nb_op_vals;i++) {
              int v = op_vals[i];
!             //if ((v & (v - 1)) != 0)
                  printf("%3d: %08x\n", i, v);
          }
          printf("size=%d nb=%d f0=%d f1=%d f2=%d f3=%d\n",
--- 678,697 ----
          memset(freq, 0, sizeof(freq));
          for(pa = asm_instrs; pa->sym != 0; pa++) {
              freq[pa->nb_ops]++;
!             /* //for(i=0;i<pa->nb_ops;i++) { */
                  for(j=0;j<nb_op_vals;j++) {
!                     /* //if (pa->op_type[i] == op_vals[j]) */
                      if (pa->instr_type == op_vals[j])
                          goto found;
                  }
!                 /* //op_vals[nb_op_vals++] = pa->op_type[i]; */
                  op_vals[nb_op_vals++] = pa->instr_type;
              found: ;
!             /* //} */
          }
          for(i=0;i<nb_op_vals;i++) {
              int v = op_vals[i];
!             /* //if ((v & (v - 1)) != 0) */
                  printf("%3d: %08x\n", i, v);
          }
          printf("size=%d nb=%d f0=%d f1=%d f2=%d f3=%d\n",
***************
*** 1281,1288 ****
              operands[k].input_index = i;
              op->priority = 5;
  	} else if ((op->vt->r & VT_VALMASK) == VT_LOCAL
! 		   && op->vt->sym
! 		   && (reg = op->vt->sym->r & VT_VALMASK) < VT_CONST) {
  	    op->priority = 1;
  	    op->reg = reg;
          } else {
--- 1301,1308 ----
              operands[k].input_index = i;
              op->priority = 5;
  	} else if ((op->vt->r & VT_VALMASK) == VT_LOCAL
! 		   && op->vt->b.sym
! 		   && (reg = op->vt->b.sym->r & VT_VALMASK) < VT_CONST) {
  	    op->priority = 1;
  	    op->reg = reg;
          } else {
***************
*** 1501,1526 ****
  	    modifier != 'P')
              cstr_ccat(add_str, '$');
          if (r & VT_SYM) {
! 	    const char *name = get_tok_str(sv->sym->v, NULL);
! 	    if (sv->sym->v >= SYM_FIRST_ANOM) {
  		/* In case of anonymous symbols ("L.42", used
  		   for static data labels) we can't find them
  		   in the C symbol table when later looking up
  		   this name.  So enter them now into the asm label
  		   list when we still know the symbol.  */
! 		get_asm_sym(tok_alloc_const(name), sv->sym);
  	    }
              if (tcc_state->leading_underscore)
                cstr_ccat(add_str, '_');
              cstr_cat(add_str, name, -1);
!             if ((uint32_t)sv->c.i == 0)
                  goto no_offset;
  	    cstr_ccat(add_str, '+');
          }
!         val = sv->c.i;
          if (modifier == 'n')
              val = -val;
!         snprintf(buf, sizeof(buf), "%d", (int)sv->c.i);
          cstr_cat(add_str, buf, -1);
      no_offset:;
  #ifdef TCC_TARGET_X86_64
--- 1521,1546 ----
  	    modifier != 'P')
              cstr_ccat(add_str, '$');
          if (r & VT_SYM) {
! 	    const char *name = get_tok_str(sv->b.sym->v, NULL);
! 	    if (sv->b.sym->v >= SYM_FIRST_ANOM) {
  		/* In case of anonymous symbols ("L.42", used
  		   for static data labels) we can't find them
  		   in the C symbol table when later looking up
  		   this name.  So enter them now into the asm label
  		   list when we still know the symbol.  */
! 		get_asm_sym(tok_alloc_const(name), sv->b.sym);
  	    }
              if (tcc_state->leading_underscore)
                cstr_ccat(add_str, '_');
              cstr_cat(add_str, name, -1);
!             if ((uint32_t)sv->a.c.i == 0)
                  goto no_offset;
  	    cstr_ccat(add_str, '+');
          }
!         val = sv->a.c.i;
          if (modifier == 'n')
              val = -val;
!         snprintf(buf, sizeof(buf), "%d", (int)sv->a.c.i);
          cstr_cat(add_str, buf, -1);
      no_offset:;
  #ifdef TCC_TARGET_X86_64
***************
*** 1529,1537 ****
  #endif
      } else if ((r & VT_VALMASK) == VT_LOCAL) {
  #ifdef TCC_TARGET_X86_64
!         snprintf(buf, sizeof(buf), "%d(%%rbp)", (int)sv->c.i);
  #else
!         snprintf(buf, sizeof(buf), "%d(%%ebp)", (int)sv->c.i);
  #endif
          cstr_cat(add_str, buf, -1);
      } else if (r & VT_LVAL) {
--- 1549,1557 ----
  #endif
      } else if ((r & VT_VALMASK) == VT_LOCAL) {
  #ifdef TCC_TARGET_X86_64
!         snprintf(buf, sizeof(buf), "%d(%%rbp)", (int)sv->a.c.i);
  #else
!         snprintf(buf, sizeof(buf), "%d(%%ebp)", (int)sv->a.c.i);
  #endif
          cstr_cat(add_str, buf, -1);
      } else if (r & VT_LVAL) {
***************
*** 1669,1675 ****
                      if (op->is_llong) {
                          SValue sv;
                          sv = *op->vt;
!                         sv.c.i += 4;
                          load(TREG_XDX, &sv);
                      }
                  }
--- 1689,1695 ----
                      if (op->is_llong) {
                          SValue sv;
                          sv = *op->vt;
!                         sv.a.c.i += 4;
                          load(TREG_XDX, &sv);
                      }
                  }
***************
*** 1697,1703 ****
                      if (op->is_llong) {
                          SValue sv;
                          sv = *op->vt;
!                         sv.c.i += 4;
                          store(TREG_XDX, &sv);
                      }
                  }
--- 1717,1723 ----
                      if (op->is_llong) {
                          SValue sv;
                          sv = *op->vt;
!                         sv.a.c.i += 4;
                          store(TREG_XDX, &sv);
                      }
                  }
diff -r -N -c a/i386-gen.c b/i386-gen.c
*** a/i386-gen.c	2022-08-18 09:34:36.000000000 +0000
--- b/i386-gen.c	2023-02-02 08:46:08.344178681 +0000
***************
*** 225,231 ****
  
      fr = sv->r;
      ft = sv->type.t & ~VT_DEFSIGN;
!     fc = sv->c.i;
  
      ft &= ~(VT_VOLATILE | VT_CONSTANT);
  
--- 225,231 ----
  
      fr = sv->r;
      ft = sv->type.t & ~VT_DEFSIGN;
!     fc = sv->a.c.i;
  
      ft &= ~(VT_VOLATILE | VT_CONSTANT);
  
***************
*** 234,241 ****
          if (v == VT_LLOCAL) {
              v1.type.t = VT_INT;
              v1.r = VT_LOCAL | VT_LVAL;
!             v1.c.i = fc;
!             v1.sym = NULL;
              fr = r;
              if (!(reg_classes[fr] & RC_INT))
                  fr = get_reg(RC_INT);
--- 234,241 ----
          if (v == VT_LLOCAL) {
              v1.type.t = VT_INT;
              v1.r = VT_LOCAL | VT_LVAL;
!             v1.a.c.i = fc;
!             v1.b.sym = NULL;
              fr = r;
              if (!(reg_classes[fr] & RC_INT))
                  fr = get_reg(RC_INT);
***************
*** 261,275 ****
          } else {
              o(0x8b);     /* movl */
          }
!         gen_modrm(r, fr, sv->sym, fc);
      } else {
          if (v == VT_CONST) {
              o(0xb8 + r); /* mov $xx, r */
!             gen_addr32(fr, sv->sym, fc);
          } else if (v == VT_LOCAL) {
              if (fc) {
                  o(0x8d); /* lea xxx(%ebp), r */
!                 gen_modrm(r, VT_LOCAL, sv->sym, fc);
              } else {
                  o(0x89);
                  o(0xe8 + r); /* mov %ebp, r */
--- 261,275 ----
          } else {
              o(0x8b);     /* movl */
          }
!         gen_modrm(r, fr, sv->b.sym, fc);
      } else {
          if (v == VT_CONST) {
              o(0xb8 + r); /* mov $xx, r */
!             gen_addr32(fr, sv->b.sym, fc);
          } else if (v == VT_LOCAL) {
              if (fc) {
                  o(0x8d); /* lea xxx(%ebp), r */
!                 gen_modrm(r, VT_LOCAL, sv->b.sym, fc);
              } else {
                  o(0x89);
                  o(0xe8 + r); /* mov %ebp, r */
***************
*** 303,309 ****
  #endif
  
      ft = v->type.t;
!     fc = v->c.i;
      fr = v->r & VT_VALMASK;
      ft &= ~(VT_VOLATILE | VT_CONSTANT);
      bt = ft & VT_BTYPE;
--- 303,309 ----
  #endif
  
      ft = v->type.t;
!     fc = v->a.c.i;
      fr = v->r & VT_VALMASK;
      ft &= ~(VT_VOLATILE | VT_CONSTANT);
      bt = ft & VT_BTYPE;
***************
*** 329,335 ****
      if (fr == VT_CONST ||
          fr == VT_LOCAL ||
          (v->r & VT_LVAL)) {
!         gen_modrm(r, v->r, v->sym, fc);
      } else if (fr != r) {
          o(0xc0 + fr + r * 8); /* mov r, fr */
      }
--- 329,335 ----
      if (fr == VT_CONST ||
          fr == VT_LOCAL ||
          (v->r & VT_LVAL)) {
!         gen_modrm(r, v->r, v->b.sym, fc);
      } else if (fr != r) {
          o(0xc0 + fr + r * 8); /* mov r, fr */
      }
***************
*** 362,369 ****
      int r;
      if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST && (vtop->r & VT_SYM)) {
          /* constant and relocation case */
!         greloc(cur_text_section, vtop->sym, ind + 1, R_386_PC32);
!         oad(0xe8 + is_jmp, vtop->c.i - 4); /* call/jmp im */
      } else {
          /* otherwise, indirect call */
          r = gv(RC_INT);
--- 362,369 ----
      int r;
      if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST && (vtop->r & VT_SYM)) {
          /* constant and relocation case */
!         greloc(cur_text_section, vtop->b.sym, ind + 1, R_386_PC32);
!         oad(0xe8 + is_jmp, vtop->a.c.i - 4); /* call/jmp im */
      } else {
          /* otherwise, indirect call */
          r = gv(RC_INT);
***************
*** 381,387 ****
  {
  #if defined(TCC_TARGET_PE) || TARGETOS_FreeBSD || TARGETOS_OpenBSD
      int size, align;
!     *ret_align = 1; // Never have to re-align return values for x86
      *regsize = 4;
      size = type_size(vt, &align);
      if (size > 8 || (size & (size - 1)))
--- 381,387 ----
  {
  #if defined(TCC_TARGET_PE) || TARGETOS_FreeBSD || TARGETOS_OpenBSD
      int size, align;
!     *ret_align = 1; /* // Never have to re-align return values for x86 */
      *regsize = 4;
      size = type_size(vt, &align);
      if (size > 8 || (size & (size - 1)))
***************
*** 397,403 ****
      ret->ref = NULL;
      return 1;
  #else
!     *ret_align = 1; // Never have to re-align return values for x86
      return 0;
  #endif
  }
--- 397,403 ----
      ret->ref = NULL;
      return 1;
  #else
!     *ret_align = 1; /* // Never have to re-align return values for x86 */
      return 0;
  #endif
  }
***************
*** 425,431 ****
  #ifdef TCC_TARGET_PE
              if (size >= 4096) {
                  r = get_reg(RC_EAX);
!                 oad(0x68, size); // push size
                  /* cannot call normal 'alloca' with bound checking */
                  gen_static_call(tok_alloc_const("__alloca"));
                  gadd_sp(4);
--- 425,431 ----
  #ifdef TCC_TARGET_PE
              if (size >= 4096) {
                  r = get_reg(RC_EAX);
!                 oad(0x68, size); /* // push size */
                  /* cannot call normal 'alloca' with bound checking */
                  gen_static_call(tok_alloc_const("__alloca"));
                  gadd_sp(4);
***************
*** 474,480 ****
      }
      save_regs(0); /* save used temporary registers */
      func_sym = vtop->type.ref;
!     func_call = func_sym->f.func_call;
      /* fast call case */
      if ((func_call >= FUNC_FASTCALL1 && func_call <= FUNC_FASTCALL3) ||
          func_call == FUNC_FASTCALLW) {
--- 474,480 ----
      }
      save_regs(0); /* save used temporary registers */
      func_sym = vtop->type.ref;
!     func_call = func_sym->b.a.a.f.func_call;
      /* fast call case */
      if ((func_call >= FUNC_FASTCALL1 && func_call <= FUNC_FASTCALL3) ||
          func_call == FUNC_FASTCALLW) {
***************
*** 524,530 ****
      CType *type;
  
      sym = func_type->ref;
!     func_call = sym->f.func_call;
      addr = 8;
      loc = 0;
      func_vc = 0;
--- 524,530 ----
      CType *type;
  
      sym = func_type->ref;
!     func_call = sym->b.a.a.f.func_call;
      addr = 8;
      loc = 0;
      func_vc = 0;
***************
*** 558,564 ****
          param_index++;
      }
      /* define parameters */
!     while ((sym = sym->next) != NULL) {
          type = &sym->type;
          size = type_size(type, &align);
          size = (size + 3) & ~3;
--- 558,564 ----
          param_index++;
      }
      /* define parameters */
!     while ((sym = sym->e.next) != NULL) {
          type = &sym->type;
          size = type_size(type, &align);
          size = (size + 3) & ~3;
***************
*** 709,720 ****
              vswap();
              r = gv(RC_INT);
              vswap();
!             c = vtop->c.i;
              if (c == (char)c) {
                  /* generate inc and dec for smaller code */
                  if ((c == 1 || c == -1) && (op == '+' || op == '-')) {
                      opc = (c == 1) ^ (op == '+');
!                     o (0x40 | (opc << 3) | r); // inc,dec
                  } else {
                      o(0x83);
                      o(0xc0 | (opc << 3) | r);
--- 709,720 ----
              vswap();
              r = gv(RC_INT);
              vswap();
!             c = vtop->a.c.i;
              if (c == (char)c) {
                  /* generate inc and dec for smaller code */
                  if ((c == 1 || c == -1) && (op == '+' || op == '-')) {
                      opc = (c == 1) ^ (op == '+');
!                     o (0x40 | (opc << 3) | r); /* // inc,dec */
                  } else {
                      o(0x83);
                      o(0xc0 | (opc << 3) | r);
***************
*** 777,783 ****
              vswap();
              r = gv(RC_INT);
              vswap();
!             c = vtop->c.i & 0x1f;
              o(0xc1); /* shl/shr/sar $xxx, r */
              o(opc | r);
              g(c);
--- 777,783 ----
              vswap();
              r = gv(RC_INT);
              vswap();
!             c = vtop->a.c.i & 0x1f;
              o(0xc1); /* shl/shr/sar $xxx, r */
              o(opc | r);
              g(c);
***************
*** 925,931 ****
              break;
          }
          ft = vtop->type.t;
!         fc = vtop->c.i;
          if ((ft & VT_BTYPE) == VT_LDOUBLE) {
              o(0xde); /* fxxxp %st, %st(1) */
              o(0xc1 + (a << 3));
--- 925,931 ----
              break;
          }
          ft = vtop->type.t;
!         fc = vtop->a.c.i;
          if ((ft & VT_BTYPE) == VT_LDOUBLE) {
              o(0xde); /* fxxxp %st, %st(1) */
              o(0xc1 + (a << 3));
***************
*** 937,944 ****
                  r = get_reg(RC_INT);
                  v1.type.t = VT_INT;
                  v1.r = VT_LOCAL | VT_LVAL;
!                 v1.c.i = fc;
!                 v1.sym = NULL;
                  load(r, &v1);
                  fc = 0;
              }
--- 937,944 ----
                  r = get_reg(RC_INT);
                  v1.type.t = VT_INT;
                  v1.r = VT_LOCAL | VT_LVAL;
!                 v1.a.c.i = fc;
!                 v1.b.sym = NULL;
                  load(r, &v1);
                  fc = 0;
              }
***************
*** 947,953 ****
                  o(0xdc);
              else
                  o(0xd8);
!             gen_modrm(a, r, vtop->sym, fc);
          }
          vtop--;
      }
--- 947,953 ----
                  o(0xdc);
              else
                  o(0xd8);
!             gen_modrm(a, r, vtop->b.sym, fc);
          }
          vtop--;
      }
***************
*** 1027,1037 ****
  ST_FUNC void gen_increment_tcov (SValue *sv)
  {
     o(0x0583); /* addl $1, xxx */
!    greloc(cur_text_section, sv->sym, ind, R_386_32);
     gen_le32(0);
     o(1);
     o(0x1583); /* addcl $0, xxx */
!    greloc(cur_text_section, sv->sym, ind, R_386_32);
     gen_le32(4);
     g(0);
  }
--- 1027,1037 ----
  ST_FUNC void gen_increment_tcov (SValue *sv)
  {
     o(0x0583); /* addl $1, xxx */
!    greloc(cur_text_section, sv->b.sym, ind, R_386_32);
     gen_le32(0);
     o(1);
     o(0x1583); /* addcl $0, xxx */
!    greloc(cur_text_section, sv->b.sym, ind, R_386_32);
     gen_le32(4);
     g(0);
  }
diff -r -N -c a/i386-tok.h b/i386-tok.h
*** a/i386-tok.h	2022-08-18 09:34:36.000000000 +0000
--- b/i386-tok.h	2023-02-02 08:46:08.492178684 +0000
***************
*** 44,49 ****
--- 44,80 ----
   DEF(TOK_ASM_ ## f ## x ## p, "f" #x "p") \
   DEF_FP1(x)
  
+ #define DEF_ASMTEST0(x) \
+  DEF_ASM(x ## o) \
+  DEF_ASM(x ## no) \
+  DEF_ASM(x ## b) \
+  DEF_ASM(x ## c) \
+  DEF_ASM(x ## nae) \
+  DEF_ASM(x ## nb) \
+  DEF_ASM(x ## nc) \
+  DEF_ASM(x ## ae) \
+  DEF_ASM(x ## e) \
+  DEF_ASM(x ## z) \
+  DEF_ASM(x ## ne) \
+  DEF_ASM(x ## nz) \
+  DEF_ASM(x ## be) \
+  DEF_ASM(x ## na) \
+  DEF_ASM(x ## nbe) \
+  DEF_ASM(x ## a) \
+  DEF_ASM(x ## s) \
+  DEF_ASM(x ## ns) \
+  DEF_ASM(x ## p) \
+  DEF_ASM(x ## pe) \
+  DEF_ASM(x ## np) \
+  DEF_ASM(x ## po) \
+  DEF_ASM(x ## l) \
+  DEF_ASM(x ## nge) \
+  DEF_ASM(x ## nl) \
+  DEF_ASM(x ## ge) \
+  DEF_ASM(x ## le) \
+  DEF_ASM(x ## ng) \
+  DEF_ASM(x ## nle) \
+  DEF_ASM(x ## g)
  #define DEF_ASMTEST(x,suffix) \
   DEF_ASM(x ## o ## suffix) \
   DEF_ASM(x ## no ## suffix) \
***************
*** 256,266 ****
   DEF_ASM(lcall)
   DEF_ASM(ljmp)
  
!  DEF_ASMTEST(j,)
  
!  DEF_ASMTEST(set,)
   DEF_ASMTEST(set,b)
!  DEF_ASMTEST(cmov,)
  
   DEF_WLX(bsf)
   DEF_WLX(bsr)
--- 287,297 ----
   DEF_ASM(lcall)
   DEF_ASM(ljmp)
  
!  DEF_ASMTEST0(j)
  
!  DEF_ASMTEST0(set)
   DEF_ASMTEST(set,b)
!  DEF_ASMTEST0(cmov)
  
   DEF_WLX(bsf)
   DEF_WLX(bsr)
diff -r -N -c a/libtcc.c b/libtcc.c
*** a/libtcc.c	2022-08-18 09:34:36.000000000 +0000
--- b/libtcc.c	2023-02-02 14:01:43.176687323 +0000
***************
*** 67,73 ****
--- 67,75 ----
  
  /* XXX: get rid of this ASAP (or maybe not) */
  ST_DATA struct TCCState *tcc_state;
+ #if CONFIG_TCC_SEMLOCK
  TCC_SEM(static tcc_compile_sem);
+ #endif
  
  #ifdef MEM_DEBUG
  static int nb_states;
***************
*** 1542,1548 ****
      TCC_OPTION_MMD,
      TCC_OPTION_x,
      TCC_OPTION_ar,
!     TCC_OPTION_impdef,
  };
  
  #define TCC_OPTION_HAS_ARG 0x0001
--- 1544,1550 ----
      TCC_OPTION_MMD,
      TCC_OPTION_x,
      TCC_OPTION_ar,
!     TCC_OPTION_impdef
  };
  
  #define TCC_OPTION_HAS_ARG 0x0001
***************
*** 1723,1729 ****
              cstr_ccat(&str, c);
          }
          cstr_ccat(&str, 0);
!         //printf("<%s>\n", str.data), fflush(stdout);
          dynarray_add(argv, argc, tcc_strdup(str.data));
          cstr_free(&str);
          ++ret;
--- 1725,1731 ----
              cstr_ccat(&str, c);
          }
          cstr_ccat(&str, 0);
!         /* //printf("<%s>\n", str.data), fflush(stdout); */
          dynarray_add(argv, argc, tcc_strdup(str.data));
          cstr_free(&str);
          ++ret;
***************
*** 1991,2002 ****
              break;
          case TCC_OPTION_M:
              s->include_sys_deps = 1;
!             // fall through
          case TCC_OPTION_MM:
              s->just_deps = 1;
              if(!s->deps_outfile)
                  s->deps_outfile = tcc_strdup("-");
!             // fall through
          case TCC_OPTION_MMD:
              s->gen_deps = 1;
              break;
--- 1993,2004 ----
              break;
          case TCC_OPTION_M:
              s->include_sys_deps = 1;
!             /* // fall through */
          case TCC_OPTION_MM:
              s->just_deps = 1;
              if(!s->deps_outfile)
                  s->deps_outfile = tcc_strdup("-");
!             /* // fall through */
          case TCC_OPTION_MMD:
              s->gen_deps = 1;
              break;
diff -r -N -c a/tccasm.c b/tccasm.c
*** a/tccasm.c	2022-08-18 09:34:36.000000000 +0000
--- b/tccasm.c	2023-02-02 09:42:59.078693665 +0000
***************
*** 73,79 ****
      int addeddot;
      v = asm2cname(v, &addeddot);
      sym = sym_find(v);
!     while (sym && sym->sym_scope && !(sym->type.t & VT_STATIC))
          sym = sym->prev_tok;
      return sym;
  }
--- 73,79 ----
      int addeddot;
      v = asm2cname(v, &addeddot);
      sym = sym_find(v);
!     while (sym && sym->b.a.a.sym_scope && !(sym->type.t & VT_STATIC))
          sym = sym->prev_tok;
      return sym;
  }
***************
*** 86,92 ****
         as is.  */
      Sym *sym = global_identifier_push(v2, VT_ASM | VT_EXTERN | VT_STATIC, 0);
      if (addeddot)
!         sym->asm_label = v;
      return sym;
  }
  
--- 86,92 ----
         as is.  */
      Sym *sym = global_identifier_push(v2, VT_ASM | VT_EXTERN | VT_STATIC, 0);
      if (addeddot)
!         sym->e.asm_label = v;
      return sym;
  }
  
***************
*** 106,112 ****
      if (!sym) {
  	sym = asm_label_push(name);
  	if (csym)
! 	  sym->c = csym->c;
      }
      return sym;
  }
--- 106,112 ----
      if (!sym) {
  	sym = asm_label_push(name);
  	if (csym)
! 	  sym->b.a.c = csym->b.a.c;
      }
      return sym;
  }
***************
*** 140,152 ****
              sym = asm_label_find(label);
              if (*p == 'b') {
                  /* backward : find the last corresponding defined label */
!                 if (sym && (!sym->c || elfsym(sym)->st_shndx == SHN_UNDEF))
                      sym = sym->prev_tok;
                  if (!sym)
                      tcc_error("local label '%d' not found backward", (int)n);
              } else {
                  /* forward */
!                 if (!sym || (sym->c && elfsym(sym)->st_shndx != SHN_UNDEF)) {
                      /* if the last label is defined, then define a new one */
  		    sym = asm_label_push(label);
                  }
--- 140,152 ----
              sym = asm_label_find(label);
              if (*p == 'b') {
                  /* backward : find the last corresponding defined label */
!                 if (sym && (!sym->b.a.c || elfsym(sym)->st_shndx == SHN_UNDEF))
                      sym = sym->prev_tok;
                  if (!sym)
                      tcc_error("local label '%d' not found backward", (int)n);
              } else {
                  /* forward */
!                 if (!sym || (sym->b.a.c && elfsym(sym)->st_shndx != SHN_UNDEF)) {
                      /* if the last label is defined, then define a new one */
  		    sym = asm_label_push(label);
                  }
***************
*** 424,430 ****
      new_label:
          sym = asm_label_push(label);
      }
!     if (!sym->c)
        put_extern_sym2(sym, SHN_UNDEF, 0, 0, 1);
      esym = elfsym(sym);
      esym->st_shndx = sh_num;
--- 424,430 ----
      new_label:
          sym = asm_label_push(label);
      }
!     if (!sym->b.a.c)
        put_extern_sym2(sym, SHN_UNDEF, 0, 0, 1);
      esym = elfsym(sym);
      esym->st_shndx = sh_num;
***************
*** 1241,1247 ****
                          next();
                          asmname = asm_get_prefix_name(tcc_state, "LG.",
                                                        ++asmgoto_n);
!                         if (!csym->c)
                            put_extern_sym2(csym, SHN_UNDEF, 0, 0, 1);
                          get_asm_sym(asmname, csym);
                          operands[nb_operands + nb_labels - 1].is_label = asmname;
--- 1241,1247 ----
                          next();
                          asmname = asm_get_prefix_name(tcc_state, "LG.",
                                                        ++asmgoto_n);
!                         if (!csym->b.a.c)
                            put_extern_sym2(csym, SHN_UNDEF, 0, 0, 1);
                          get_asm_sym(asmname, csym);
                          operands[nb_operands + nb_labels - 1].is_label = asmname;
diff -r -N -c a/tcc.c b/tcc.c
*** a/tcc.c	2022-08-18 09:34:36.000000000 +0000
--- b/tcc.c	2023-02-02 08:46:08.948178693 +0000
***************
*** 277,282 ****
--- 277,286 ----
      const char *first_file;
      int argc; char **argv;
      FILE *ppfp = stdout;
+     void fill_asm_instrs();
+ 
+ /* initialize some structures */
+     fill_asm_instrs();
  
  redo:
      argc = argc0, argv = argv0;
diff -r -N -c a/tccdbg.c b/tccdbg.c
*** a/tccdbg.c	2022-08-18 09:34:36.000000000 +0000
--- b/tccdbg.c	2023-02-02 08:46:10.644178729 +0000
***************
*** 393,399 ****
      /* include stab info with standalone backtrace support */
      if (s1->do_backtrace
          && (s1->output_type & (TCC_OUTPUT_EXE | TCC_OUTPUT_DLL)))
!         shf = SHF_ALLOC | SHF_WRITE; // SHF_WRITE needed for musl/SELINUX
  #endif
      if (s1->dwarf) {
          s1->dwlo = s1->nb_sections;
--- 393,399 ----
      /* include stab info with standalone backtrace support */
      if (s1->do_backtrace
          && (s1->output_type & (TCC_OUTPUT_EXE | TCC_OUTPUT_DLL)))
!         shf = SHF_ALLOC | SHF_WRITE; /* // SHF_WRITE needed for musl/SELINUX */
  #endif
      if (s1->dwarf) {
          s1->dwlo = s1->nb_sections;
***************
*** 726,735 ****
  
              /* dwarf_info */
              dwarf_info.start = dwarf_info_section->data_offset;
!             dwarf_data4(dwarf_info_section, 0); // size
!             dwarf_data2(dwarf_info_section, s1->dwarf); // version
              if (s1->dwarf >= 5) {
!                 dwarf_data1(dwarf_info_section, DW_UT_compile); // unit type
                  dwarf_data1(dwarf_info_section, PTR_SIZE);
                  dwarf_reloc(dwarf_info_section, dwarf_sym.abbrev, R_DATA_32DW);
                  dwarf_data4(dwarf_info_section, start_abbrev);
--- 726,735 ----
  
              /* dwarf_info */
              dwarf_info.start = dwarf_info_section->data_offset;
!             dwarf_data4(dwarf_info_section, 0); /* // size */
!             dwarf_data2(dwarf_info_section, s1->dwarf); /* // version */
              if (s1->dwarf >= 5) {
!                 dwarf_data1(dwarf_info_section, DW_UT_compile); /* // unit type */
                  dwarf_data1(dwarf_info_section, PTR_SIZE);
                  dwarf_reloc(dwarf_info_section, dwarf_sym.abbrev, R_DATA_32DW);
                  dwarf_data4(dwarf_info_section, start_abbrev);
***************
*** 747,774 ****
              dwarf_line_strp(dwarf_info_section, buf);
              dwarf_reloc(dwarf_info_section, section_sym, R_DATA_PTR);
  #if PTR_SIZE == 4
!             dwarf_data4(dwarf_info_section, ind); // low pc
!             dwarf_data4(dwarf_info_section, 0); // high pc
  #else
!             dwarf_data8(dwarf_info_section, ind); // low pc
!             dwarf_data8(dwarf_info_section, 0); // high pc
  #endif
              dwarf_reloc(dwarf_info_section, dwarf_sym.line, R_DATA_32DW);
!             dwarf_data4(dwarf_info_section, dwarf_line_section->data_offset); // stmt_list
  
              /* dwarf_line */
              dwarf_line.start = dwarf_line_section->data_offset;
!             dwarf_data4(dwarf_line_section, 0); // length
!             dwarf_data2(dwarf_line_section, s1->dwarf); // version
              if (s1->dwarf >= 5) {
!                 dwarf_data1(dwarf_line_section, PTR_SIZE); // address size
!                 dwarf_data1(dwarf_line_section, 0); // segment selector
              }
!             dwarf_data4(dwarf_line_section, 0); // prologue Length
              dwarf_data1(dwarf_line_section, DWARF_MIN_INSTR_LEN);
              if (s1->dwarf >= 4)
!                 dwarf_data1(dwarf_line_section, 1); // maximum ops per instruction
!             dwarf_data1(dwarf_line_section, 1); // Initial value of 'is_stmt'
              dwarf_data1(dwarf_line_section, DWARF_LINE_BASE);
              dwarf_data1(dwarf_line_section, DWARF_LINE_RANGE);
              dwarf_data1(dwarf_line_section, DWARF_OPCODE_BASE);
--- 747,774 ----
              dwarf_line_strp(dwarf_info_section, buf);
              dwarf_reloc(dwarf_info_section, section_sym, R_DATA_PTR);
  #if PTR_SIZE == 4
!             dwarf_data4(dwarf_info_section, ind); /* // low pc */
!             dwarf_data4(dwarf_info_section, 0); /* // high pc */
  #else
!             dwarf_data8(dwarf_info_section, ind); /* // low pc */
!             dwarf_data8(dwarf_info_section, 0); /* // high pc */
  #endif
              dwarf_reloc(dwarf_info_section, dwarf_sym.line, R_DATA_32DW);
!             dwarf_data4(dwarf_info_section, dwarf_line_section->data_offset); /* // stmt_list */
  
              /* dwarf_line */
              dwarf_line.start = dwarf_line_section->data_offset;
!             dwarf_data4(dwarf_line_section, 0); /* // length */
!             dwarf_data2(dwarf_line_section, s1->dwarf); /* // version */
              if (s1->dwarf >= 5) {
!                 dwarf_data1(dwarf_line_section, PTR_SIZE); /* // address size */
!                 dwarf_data1(dwarf_line_section, 0); /* // segment selector */
              }
!             dwarf_data4(dwarf_line_section, 0); /* // prologue Length */
              dwarf_data1(dwarf_line_section, DWARF_MIN_INSTR_LEN);
              if (s1->dwarf >= 4)
!                 dwarf_data1(dwarf_line_section, 1); /* // maximum ops per instruction */
!             dwarf_data1(dwarf_line_section, 1); /* // Initial value of 'is_stmt' */
              dwarf_data1(dwarf_line_section, DWARF_LINE_BASE);
              dwarf_data1(dwarf_line_section, DWARF_LINE_RANGE);
              dwarf_data1(dwarf_line_section, DWARF_OPCODE_BASE);
***************
*** 806,813 ****
              dwarf_line.last_file = 0;
              dwarf_line.last_pc = 0;
              dwarf_line.last_line = 1;
!             dwarf_line_op(s1, 0); // extended
!             dwarf_uleb128_op(s1, 1 + PTR_SIZE); // extended size
              dwarf_line_op(s1, DW_LNE_set_address);
              for (i = 0; i < PTR_SIZE; i++)
      	        dwarf_line_op(s1, 0);
--- 806,813 ----
              dwarf_line.last_file = 0;
              dwarf_line.last_pc = 0;
              dwarf_line.last_line = 1;
!             dwarf_line_op(s1, 0); /* // extended */
!             dwarf_uleb128_op(s1, 1 + PTR_SIZE); /* // extended size */
              dwarf_line_op(s1, DW_LNE_set_address);
              for (i = 0; i < PTR_SIZE; i++)
      	        dwarf_line_op(s1, 0);
***************
*** 874,901 ****
  
  	/* dwarf_aranges */
  	start_aranges = dwarf_aranges_section->data_offset;
! 	dwarf_data4(dwarf_aranges_section, 0); // size
! 	dwarf_data2(dwarf_aranges_section, 2); // version
  	dwarf_reloc(dwarf_aranges_section, dwarf_sym.info, R_DATA_32DW);
! 	dwarf_data4(dwarf_aranges_section, 0); // dwarf_info
  #if PTR_SIZE == 4
! 	dwarf_data1(dwarf_aranges_section, 4); // address size
  #else
! 	dwarf_data1(dwarf_aranges_section, 8); // address size
  #endif
! 	dwarf_data1(dwarf_aranges_section, 0); // segment selector size
! 	dwarf_data4(dwarf_aranges_section, 0); // padding
  	dwarf_reloc(dwarf_aranges_section, section_sym, R_DATA_PTR);
  #if PTR_SIZE == 4
! 	dwarf_data4(dwarf_aranges_section, 0); // Begin
! 	dwarf_data4(dwarf_aranges_section, text_size); // End
! 	dwarf_data4(dwarf_aranges_section, 0); // End list
! 	dwarf_data4(dwarf_aranges_section, 0); // End list
  #else
! 	dwarf_data8(dwarf_aranges_section, 0); // Begin
! 	dwarf_data8(dwarf_aranges_section, text_size); // End
! 	dwarf_data8(dwarf_aranges_section, 0); // End list
! 	dwarf_data8(dwarf_aranges_section, 0); // End list
  #endif
  	ptr = dwarf_aranges_section->data + start_aranges;
  	write32le(ptr, dwarf_aranges_section->data_offset - start_aranges - 4);
--- 874,901 ----
  
  	/* dwarf_aranges */
  	start_aranges = dwarf_aranges_section->data_offset;
! 	dwarf_data4(dwarf_aranges_section, 0); /* // size */
! 	dwarf_data2(dwarf_aranges_section, 2); /* // version */
  	dwarf_reloc(dwarf_aranges_section, dwarf_sym.info, R_DATA_32DW);
! 	dwarf_data4(dwarf_aranges_section, 0); /* // dwarf_info */
  #if PTR_SIZE == 4
! 	dwarf_data1(dwarf_aranges_section, 4); /* // address size */
  #else
! 	dwarf_data1(dwarf_aranges_section, 8); /* // address size */
  #endif
! 	dwarf_data1(dwarf_aranges_section, 0); /* // segment selector size */
! 	dwarf_data4(dwarf_aranges_section, 0); /* // padding */
  	dwarf_reloc(dwarf_aranges_section, section_sym, R_DATA_PTR);
  #if PTR_SIZE == 4
! 	dwarf_data4(dwarf_aranges_section, 0); /* // Begin */
! 	dwarf_data4(dwarf_aranges_section, text_size); /* // End */
! 	dwarf_data4(dwarf_aranges_section, 0); /* // End list */
! 	dwarf_data4(dwarf_aranges_section, 0); /* // End list */
  #else
! 	dwarf_data8(dwarf_aranges_section, 0); /* // Begin */
! 	dwarf_data8(dwarf_aranges_section, text_size); /* // End */
! 	dwarf_data8(dwarf_aranges_section, 0); /* // End list */
! 	dwarf_data8(dwarf_aranges_section, 0); /* // End list */
  #endif
  	ptr = dwarf_aranges_section->data + start_aranges;
  	write32le(ptr, dwarf_aranges_section->data_offset - start_aranges - 4);
***************
*** 948,955 ****
  	    tcc_free(dwarf_line.filename_table[i].name);
  	tcc_free(dwarf_line.filename_table);
  
! 	dwarf_line_op(s1, 0); // extended
! 	dwarf_uleb128_op(s1, 1); // extended size
  	dwarf_line_op(s1, DW_LNE_end_sequence);
  	i = (s1->dwarf >= 5) * 2;
  	write32le(&dwarf_line_section->data[dwarf_line.start + 6 + i],
--- 948,955 ----
  	    tcc_free(dwarf_line.filename_table[i].name);
  	tcc_free(dwarf_line.filename_table);
  
! 	dwarf_line_op(s1, 0); /* // extended */
! 	dwarf_uleb128_op(s1, 1); /* // extended size */
  	dwarf_line_op(s1, DW_LNE_end_sequence);
  	i = (s1->dwarf >= 5) * 2;
  	write32le(&dwarf_line_section->data[dwarf_line.start + 6 + i],
***************
*** 973,979 ****
  static BufferedFile* put_new_file(TCCState *s1)
  {
      BufferedFile *f = file;
!     /* use upper file if from inline ":asm:" */
      if (f->filename[0] == ':')
          f = f->prev;
      if (f && new_file) {
--- 973,979 ----
  static BufferedFile* put_new_file(TCCState *s1)
  {
      BufferedFile *f = file;
!     /* use upper file if from ":asm:" */
      if (f->filename[0] == ':')
          f = f->prev;
      if (f && new_file) {
***************
*** 1195,1201 ****
      int i;
  
      if (!debug_info && dwarf &&
! 	(t->type.t & VT_BTYPE) == VT_STRUCT && t->c == -1) {
  	for (i = 0; i < n_debug_anon_hash; i++)
              if (t == debug_anon_hash[i].type)
  		return 0;
--- 1195,1201 ----
      int i;
  
      if (!debug_info && dwarf &&
! 	(t->type.t & VT_BTYPE) == VT_STRUCT && t->b.a.c == -1) {
  	for (i = 0; i < n_debug_anon_hash; i++)
              if (t == debug_anon_hash[i].type)
  		return 0;
***************
*** 1219,1225 ****
  {
      int i;
  
!     if (!debug_info && (t->type.t & VT_BTYPE) == VT_STRUCT && t->type.ref->c == -1)
  	for (i = 0; i < n_debug_anon_hash; i++)
              if (t->type.ref == debug_anon_hash[i].type) {
  		debug_anon_hash[i].debug_type =
--- 1219,1225 ----
  {
      int i;
  
!     if (!debug_info && (t->type.t & VT_BTYPE) == VT_STRUCT && t->type.ref->b.a.c == -1)
  	for (i = 0; i < n_debug_anon_hash; i++)
              if (t->type.ref == debug_anon_hash[i].type) {
  		debug_anon_hash[i].debug_type =
***************
*** 1236,1242 ****
  
      if (!s1->dState || !s1->dwarf || debug_info)
  	return;
!     if ((t->t & VT_BTYPE) == VT_STRUCT && t->ref->c != -1)
  	for (i = 0; i < n_debug_anon_hash; i++)
  	    if (t->ref == debug_anon_hash[i].type) {
  		Sym sym = {0}; sym .type = *t ;
--- 1236,1242 ----
  
      if (!s1->dState || !s1->dwarf || debug_info)
  	return;
!     if ((t->t & VT_BTYPE) == VT_STRUCT && t->ref->b.a.c != -1)
  	for (i = 0; i < n_debug_anon_hash; i++)
  	    if (t->ref == debug_anon_hash[i].type) {
  		Sym sym = {0}; sym .type = *t ;
***************
*** 1309,1329 ****
                           ? "" : get_tok_str(t->v & ~SYM_STRUCT, NULL),
                           debug_type,
                           IS_UNION (t->type.t) ? 'u' : 's',
!                          t->c);
!             while (t->next) {
                  int pos, size, align;
  
!                 t = t->next;
                  cstr_printf (&str, "%s:",
                               (t->v & ~SYM_FIELD) >= SYM_FIRST_ANOM
                               ? "" : get_tok_str(t->v & ~SYM_FIELD, NULL));
                  tcc_get_debug_info (s1, t, &str);
                  if (t->type.t & VT_BITFIELD) {
!                     pos = t->c * 8 + BIT_POS(t->type.t);
                      size = BIT_SIZE(t->type.t);
                  }
                  else {
!                     pos = t->c * 8;
                      size = type_size(&t->type, &align) * 8;
                  }
                  cstr_printf (&str, ",%d,%d;", pos, size);
--- 1309,1329 ----
                           ? "" : get_tok_str(t->v & ~SYM_STRUCT, NULL),
                           debug_type,
                           IS_UNION (t->type.t) ? 'u' : 's',
!                          t->b.a.c);
!             while (t->e.next) {
                  int pos, size, align;
  
!                 t = t->e.next;
                  cstr_printf (&str, "%s:",
                               (t->v & ~SYM_FIELD) >= SYM_FIRST_ANOM
                               ? "" : get_tok_str(t->v & ~SYM_FIELD, NULL));
                  tcc_get_debug_info (s1, t, &str);
                  if (t->type.t & VT_BITFIELD) {
!                     pos = t->b.a.c * 8 + BIT_POS(t->type.t);
                      size = BIT_SIZE(t->type.t);
                  }
                  else {
!                     pos = t->b.a.c * 8;
                      size = type_size(&t->type, &align) * 8;
                  }
                  cstr_printf (&str, ",%d,%d;", pos, size);
***************
*** 1346,1358 ****
                           (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM
                           ? "" : get_tok_str(t->v & ~SYM_STRUCT, NULL),
                           debug_type);
!             while (t->next) {
!                 t = t->next;
                  cstr_printf (&str, "%s:",
                               (t->v & ~SYM_FIELD) >= SYM_FIRST_ANOM
                               ? "" : get_tok_str(t->v & ~SYM_FIELD, NULL));
                  cstr_printf (&str, e->type.t & VT_UNSIGNED ? "%u," : "%d,",
!                              (int)t->enum_val);
              }
              cstr_printf (&str, ";");
              tcc_debug_stabs(s1, str.data, N_LSYM, 0, NULL, 0, 0);
--- 1346,1358 ----
                           (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM
                           ? "" : get_tok_str(t->v & ~SYM_STRUCT, NULL),
                           debug_type);
!             while (t->e.next) {
!                 t = t->e.next;
                  cstr_printf (&str, "%s:",
                               (t->v & ~SYM_FIELD) >= SYM_FIRST_ANOM
                               ? "" : get_tok_str(t->v & ~SYM_FIELD, NULL));
                  cstr_printf (&str, e->type.t & VT_UNSIGNED ? "%u," : "%d,",
!                              (int)t->b.enum_val);
              }
              cstr_printf (&str, ";");
              tcc_debug_stabs(s1, str.data, N_LSYM, 0, NULL, 0, 0);
***************
*** 1380,1386 ****
              cstr_printf (result, "%d=*", ++debug_next_type);
          else if (type == (VT_PTR | VT_ARRAY))
              cstr_printf (result, "%d=ar1;0;%d;",
!                          ++debug_next_type, t->type.ref->c - 1);
          else if (type == VT_FUNC) {
              cstr_printf (result, "%d=f", ++debug_next_type);
              tcc_get_debug_info (s1, t->type.ref, result);
--- 1380,1386 ----
              cstr_printf (result, "%d=*", ++debug_next_type);
          else if (type == (VT_PTR | VT_ARRAY))
              cstr_printf (result, "%d=ar1;0;%d;",
!                          ++debug_next_type, t->type.ref->b.a.c - 1);
          else if (type == VT_FUNC) {
              cstr_printf (result, "%d=f", ++debug_next_type);
              tcc_get_debug_info (s1, t->type.ref, result);
***************
*** 1422,1429 ****
  	    debug_type = tcc_debug_add(s1, t, 1);
  	    e = t;
  	    i = 0;
! 	    while (e->next) {
! 		e = e->next;
  		i++;
  	    }
  	    pos_type = (int *) tcc_malloc(i * sizeof(int));
--- 1422,1429 ----
  	    debug_type = tcc_debug_add(s1, t, 1);
  	    e = t;
  	    i = 0;
! 	    while (e->e.next) {
! 		e = e->e.next;
  		i++;
  	    }
  	    pos_type = (int *) tcc_malloc(i * sizeof(int));
***************
*** 1433,1447 ****
  	    dwarf_strp(dwarf_info_section,
                         (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM
                         ? "" : get_tok_str(t->v & ~SYM_STRUCT, NULL));
! 	    dwarf_uleb128(dwarf_info_section, t->c);
  	    dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);
  	    dwarf_uleb128(dwarf_info_section, file->line_num);
  	    pos_sib = dwarf_info_section->data_offset;
  	    dwarf_data4(dwarf_info_section, 0);
  	    e = t;
  	    i = 0;
!             while (e->next) {
!                 e = e->next;
  	        dwarf_data1(dwarf_info_section,
  			    e->type.t & VT_BITFIELD ? DWARF_ABBREV_MEMBER_BF
  						    : DWARF_ABBREV_MEMBER);
--- 1433,1447 ----
  	    dwarf_strp(dwarf_info_section,
                         (t->v & ~SYM_STRUCT) >= SYM_FIRST_ANOM
                         ? "" : get_tok_str(t->v & ~SYM_STRUCT, NULL));
! 	    dwarf_uleb128(dwarf_info_section, t->b.a.c);
  	    dwarf_uleb128(dwarf_info_section, dwarf_line.cur_file);
  	    dwarf_uleb128(dwarf_info_section, file->line_num);
  	    pos_sib = dwarf_info_section->data_offset;
  	    dwarf_data4(dwarf_info_section, 0);
  	    e = t;
  	    i = 0;
!             while (e->e.next) {
!                 e = e->e.next;
  	        dwarf_data1(dwarf_info_section,
  			    e->type.t & VT_BITFIELD ? DWARF_ABBREV_MEMBER_BF
  						    : DWARF_ABBREV_MEMBER);
***************
*** 1453,1474 ****
  		pos_type[i++] = dwarf_info_section->data_offset;
  		dwarf_data4(dwarf_info_section, 0);
                  if (e->type.t & VT_BITFIELD) {
!                     int pos = e->c * 8 + BIT_POS(e->type.t);
                      int size = BIT_SIZE(e->type.t);
  
  		    dwarf_uleb128(dwarf_info_section, size);
  		    dwarf_uleb128(dwarf_info_section, pos);
  		}
  		else
! 		    dwarf_uleb128(dwarf_info_section, e->c);
  	    }
  	    dwarf_data1(dwarf_info_section, 0);
  	    write32le(dwarf_info_section->data + pos_sib,
  		      dwarf_info_section->data_offset - dwarf_info.start);
  	    e = t;
  	    i = 0;
! 	    while (e->next) {
! 		e = e->next;
  		type = tcc_get_dwarf_info(s1, e);
  		tcc_debug_check_anon(s1, e, pos_type[i]);
  		write32le(dwarf_info_section->data + pos_type[i++],
--- 1453,1474 ----
  		pos_type[i++] = dwarf_info_section->data_offset;
  		dwarf_data4(dwarf_info_section, 0);
                  if (e->type.t & VT_BITFIELD) {
!                     int pos = e->b.a.c * 8 + BIT_POS(e->type.t);
                      int size = BIT_SIZE(e->type.t);
  
  		    dwarf_uleb128(dwarf_info_section, size);
  		    dwarf_uleb128(dwarf_info_section, pos);
  		}
  		else
! 		    dwarf_uleb128(dwarf_info_section, e->b.a.c);
  	    }
  	    dwarf_data1(dwarf_info_section, 0);
  	    write32le(dwarf_info_section->data + pos_sib,
  		      dwarf_info_section->data_offset - dwarf_info.start);
  	    e = t;
  	    i = 0;
! 	    while (e->e.next) {
! 		e = e->e.next;
  		type = tcc_get_dwarf_info(s1, e);
  		tcc_debug_check_anon(s1, e, pos_type[i]);
  		write32le(dwarf_info_section->data + pos_type[i++],
***************
*** 1501,1508 ****
  	    pos_sib = dwarf_info_section->data_offset;
  	    dwarf_data4(dwarf_info_section, 0);
  	    e = t;
!             while (e->next) {
!                 e = e->next;
  	        dwarf_data1(dwarf_info_section,
  			type & VT_UNSIGNED ? DWARF_ABBREV_ENUMERATOR_UNSIGNED
  					   : DWARF_ABBREV_ENUMERATOR_SIGNED);
--- 1501,1508 ----
  	    pos_sib = dwarf_info_section->data_offset;
  	    dwarf_data4(dwarf_info_section, 0);
  	    e = t;
!             while (e->e.next) {
!                 e = e->e.next;
  	        dwarf_data1(dwarf_info_section,
  			type & VT_UNSIGNED ? DWARF_ABBREV_ENUMERATOR_UNSIGNED
  					   : DWARF_ABBREV_ENUMERATOR_SIGNED);
***************
*** 1510,1518 ****
                             (e->v & ~SYM_FIELD) >= SYM_FIRST_ANOM
                             ? "" : get_tok_str(e->v & ~SYM_FIELD, NULL));
  		if (type & VT_UNSIGNED)
! 	            dwarf_uleb128(dwarf_info_section, e->enum_val);
  		else
! 	            dwarf_sleb128(dwarf_info_section, e->enum_val);
              }
  	    dwarf_data1(dwarf_info_section, 0);
  	    write32le(dwarf_info_section->data + pos_sib,
--- 1510,1518 ----
                             (e->v & ~SYM_FIELD) >= SYM_FIRST_ANOM
                             ? "" : get_tok_str(e->v & ~SYM_FIELD, NULL));
  		if (type & VT_UNSIGNED)
! 	            dwarf_uleb128(dwarf_info_section, e->b.enum_val);
  		else
! 	            dwarf_sleb128(dwarf_info_section, e->b.enum_val);
              }
  	    dwarf_data1(dwarf_info_section, 0);
  	    write32le(dwarf_info_section->data + pos_sib,
***************
*** 1590,1596 ****
  	    for (;;) {
  	        dwarf_data1(dwarf_info_section, DWARF_ABBREV_SUBRANGE_TYPE);
  	        dwarf_data4(dwarf_info_section, sub_type - dwarf_info.start);
! 	        dwarf_uleb128(dwarf_info_section, t->type.ref->c - 1);
  		s = t->type.ref;
  		type = s->type.t & ~(VT_STORAGE | VT_CONSTANT | VT_VOLATILE);
  		if (type != (VT_PTR | VT_ARRAY))
--- 1590,1596 ----
  	    for (;;) {
  	        dwarf_data1(dwarf_info_section, DWARF_ABBREV_SUBRANGE_TYPE);
  	        dwarf_data4(dwarf_info_section, sub_type - dwarf_info.start);
! 	        dwarf_uleb128(dwarf_info_section, t->type.ref->b.a.c - 1);
  		s = t->type.ref;
  		type = s->type.t & ~(VT_STORAGE | VT_CONSTANT | VT_VOLATILE);
  		if (type != (VT_PTR | VT_ARRAY))
***************
*** 1622,1636 ****
  	    dwarf_data4(dwarf_info_section, 0);
  	    f = t->type.ref;
  	    i = 0;
! 	    while (f->next) {
! 		f = f->next;
  		i++;
  	    }
  	    pos_type = (int *) tcc_malloc(i * sizeof(int));
  	    f = t->type.ref;
  	    i = 0;
! 	    while (f->next) {
! 		f = f->next;
  	        dwarf_data1(dwarf_info_section, DWARF_ABBREV_FORMAL_PARAMETER2);
  		pos_type[i++] = dwarf_info_section->data_offset;
  	        dwarf_data4(dwarf_info_section, 0);
--- 1622,1636 ----
  	    dwarf_data4(dwarf_info_section, 0);
  	    f = t->type.ref;
  	    i = 0;
! 	    while (f->e.next) {
! 		f = f->e.next;
  		i++;
  	    }
  	    pos_type = (int *) tcc_malloc(i * sizeof(int));
  	    f = t->type.ref;
  	    i = 0;
! 	    while (f->e.next) {
! 		f = f->e.next;
  	        dwarf_data1(dwarf_info_section, DWARF_ABBREV_FORMAL_PARAMETER2);
  		pos_type[i++] = dwarf_info_section->data_offset;
  	        dwarf_data4(dwarf_info_section, 0);
***************
*** 1640,1647 ****
  		      dwarf_info_section->data_offset - dwarf_info.start);
  	    f = t->type.ref;
  	    i = 0;
! 	    while (f->next) {
! 		f = f->next;
  		type = tcc_get_dwarf_info(s1, f);
  		tcc_debug_check_anon(s1, f, pos_type[i]);
  	        write32le(dwarf_info_section->data + pos_type[i++],
--- 1640,1647 ----
  		      dwarf_info_section->data_offset - dwarf_info.start);
  	    f = t->type.ref;
  	    i = 0;
! 	    while (f->e.next) {
! 		f = f->e.next;
  		type = tcc_get_dwarf_info(s1, f);
  		tcc_debug_check_anon(s1, f, pos_type[i]);
  	        write32le(dwarf_info_section->data + pos_type[i++],
***************
*** 1755,1761 ****
              continue;
  	if (s1->dwarf) {
  	    tcc_debug_stabs(s1, get_tok_str(s->v, NULL),
! 			    param ? N_PSYM : N_LSYM, s->c, NULL, 0,
  			    tcc_get_dwarf_info(s1, s));
  	}
  	else
--- 1755,1761 ----
              continue;
  	if (s1->dwarf) {
  	    tcc_debug_stabs(s1, get_tok_str(s->v, NULL),
! 			    param ? N_PSYM : N_LSYM, s->b.a.c, NULL, 0,
  			    tcc_get_dwarf_info(s1, s));
  	}
  	else
***************
*** 1765,1771 ****
  			 param ? "p" : "");
              tcc_get_debug_info(s1, s, &debug_str);
              tcc_debug_stabs(s1, debug_str.data, param ? N_PSYM : N_LSYM,
! 			    s->c, NULL, 0, 0);
  	}
      }
      cstr_free (&debug_str);
--- 1765,1771 ----
  			 param ? "p" : "");
              tcc_get_debug_info(s1, s, &debug_str);
              tcc_debug_stabs(s1, debug_str.data, param ? N_PSYM : N_LSYM,
! 			    s->b.a.c, NULL, 0, 0);
  	}
      }
      cstr_free (&debug_str);
***************
*** 1794,1800 ****
  	if (s1->do_backtrace) {
  	    int i, len;
  
! 	    dwarf_line_op(s1, 0); // extended
  	    dwarf_uleb128_op(s1, strlen(funcname) + 2);
  	    dwarf_line_op(s1, DW_LNE_hi_user - 1);
  	    len = strlen(funcname) + 1;
--- 1794,1800 ----
  	if (s1->do_backtrace) {
  	    int i, len;
  
! 	    dwarf_line_op(s1, 0); /* // extended */
  	    dwarf_uleb128_op(s1, strlen(funcname) + 2);
  	    dwarf_line_op(s1, DW_LNE_hi_user - 1);
  	    len = strlen(funcname) + 1;
***************
*** 1807,1813 ****
          cstr_new (&debug_str);
          cstr_printf(&debug_str, "%s:%c", funcname, sym->type.t & VT_STATIC ? 'f' : 'F');
          tcc_get_debug_info(s1, sym->type.ref, &debug_str);
!         put_stabs_r(s1, debug_str.data, N_FUN, 0, f->line_num, 0, cur_text_section, sym->c);
          cstr_free (&debug_str);
          tcc_debug_line(s1);
      }
--- 1807,1813 ----
          cstr_new (&debug_str);
          cstr_printf(&debug_str, "%s:%c", funcname, sym->type.t & VT_STATIC ? 'f' : 'F');
          tcc_get_debug_info(s1, sym->type.ref, &debug_str);
!         put_stabs_r(s1, debug_str.data, N_FUN, 0, f->line_num, 0, cur_text_section, sym->b.a.c);
          cstr_free (&debug_str);
          tcc_debug_line(s1);
      }
***************
*** 1837,1861 ****
          dwarf_data4(dwarf_info_section, n_debug_info - dwarf_info.start);
          dwarf_reloc(dwarf_info_section, section_sym, R_DATA_PTR);
  #if PTR_SIZE == 4
!         dwarf_data4(dwarf_info_section, func_ind); // low_pc
!         dwarf_data4(dwarf_info_section, size); // high_pc
  #else
!         dwarf_data8(dwarf_info_section, func_ind); // low_pc
!         dwarf_data8(dwarf_info_section, size); // high_pc
  #endif
          func_sib = dwarf_info_section->data_offset;
!         dwarf_data4(dwarf_info_section, 0); // sibling
          dwarf_data1(dwarf_info_section, 1);
  #if defined(TCC_TARGET_I386)
!         dwarf_data1(dwarf_info_section, DW_OP_reg5); // ebp
  #elif defined(TCC_TARGET_X86_64)
!         dwarf_data1(dwarf_info_section, DW_OP_reg6); // rbp
  #elif defined TCC_TARGET_ARM
!         dwarf_data1(dwarf_info_section, DW_OP_reg13); // sp
  #elif defined TCC_TARGET_ARM64
!         dwarf_data1(dwarf_info_section, DW_OP_reg29); // reg 29
  #elif defined TCC_TARGET_RISCV64
!         dwarf_data1(dwarf_info_section, DW_OP_reg8); // r8(s0)
  #else
          dwarf_data1(dwarf_info_section, DW_OP_call_frame_cfa);
  #endif
--- 1837,1861 ----
          dwarf_data4(dwarf_info_section, n_debug_info - dwarf_info.start);
          dwarf_reloc(dwarf_info_section, section_sym, R_DATA_PTR);
  #if PTR_SIZE == 4
!         dwarf_data4(dwarf_info_section, func_ind); /* // low_pc */
!         dwarf_data4(dwarf_info_section, size); /* // high_pc */
  #else
!         dwarf_data8(dwarf_info_section, func_ind); /* // low_pc */
!         dwarf_data8(dwarf_info_section, size); /* // high_pc */
  #endif
          func_sib = dwarf_info_section->data_offset;
!         dwarf_data4(dwarf_info_section, 0); /* // sibling */
          dwarf_data1(dwarf_info_section, 1);
  #if defined(TCC_TARGET_I386)
!         dwarf_data1(dwarf_info_section, DW_OP_reg5); /* // ebp */
  #elif defined(TCC_TARGET_X86_64)
!         dwarf_data1(dwarf_info_section, DW_OP_reg6); /* // rbp */
  #elif defined TCC_TARGET_ARM
!         dwarf_data1(dwarf_info_section, DW_OP_reg13); /* // sp */
  #elif defined TCC_TARGET_ARM64
!         dwarf_data1(dwarf_info_section, DW_OP_reg29); /* // reg 29 */
  #elif defined TCC_TARGET_RISCV64
!         dwarf_data1(dwarf_info_section, DW_OP_reg8); /* // r8(s0) */
  #else
          dwarf_data1(dwarf_info_section, DW_OP_call_frame_cfa);
  #endif
***************
*** 1918,1924 ****
          else
              tcc_debug_stabs(s1, str.data,
                  (sym->type.t & VT_STATIC) && data_section == s
!                 ? N_STSYM : N_LCSYM, 0, s, sym->c, 0);
          cstr_free (&str);
      }
  }
--- 1918,1924 ----
          else
              tcc_debug_stabs(s1, str.data,
                  (sym->type.t & VT_STATIC) && data_section == s
!                 ? N_STSYM : N_LCSYM, 0, s, sym->b.a.c, 0);
          cstr_free (&str);
      }
  }
***************
*** 2025,2032 ****
          sv.type = label.type;
          sv.r = VT_SYM | VT_LVAL | VT_CONST;
          sv.r2 = VT_CONST;
!         sv.c.i = 0;
!         sv.sym = &label;
  #if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64 || \
      defined TCC_TARGET_ARM || defined TCC_TARGET_ARM64 || \
      defined TCC_TARGET_RISCV64
--- 2025,2032 ----
          sv.type = label.type;
          sv.r = VT_SYM | VT_LVAL | VT_CONST;
          sv.r2 = VT_CONST;
!         sv.a.c.i = 0;
!         sv.b.sym = &label;
  #if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64 || \
      defined TCC_TARGET_ARM || defined TCC_TARGET_ARM64 || \
      defined TCC_TARGET_RISCV64
***************
*** 2081,2087 ****
      if (tcov_section == NULL) {
          tcov_section = new_section(tcc_state, ".tcov", SHT_PROGBITS,
  				   SHF_ALLOC | SHF_WRITE);
! 	section_ptr_add(tcov_section, 4); // pointer to executable name
      }
  }
  
--- 2081,2087 ----
      if (tcov_section == NULL) {
          tcov_section = new_section(tcc_state, ".tcov", SHT_PROGBITS,
  				   SHF_ALLOC | SHF_WRITE);
! 	section_ptr_add(tcov_section, 4); /* // pointer to executable name */
      }
  }
  
diff -r -N -c a/tccelf.c b/tccelf.c
*** a/tccelf.c	2022-08-18 09:34:36.000000000 +0000
--- b/tccelf.c	2023-02-02 09:27:56.080231413 +0000
***************
*** 174,181 ****
      for (i = 0; i < nb_syms; ++i) {
          ElfSym *sym = (ElfSym*)s->data + first_sym + i;
          if (sym->st_shndx == SHN_UNDEF
!             && ELFW(ST_BIND)(sym->st_info) == STB_LOCAL)
!             sym->st_info = ELFW(ST_INFO)(STB_GLOBAL, ELFW(ST_TYPE)(sym->st_info));
          tr[i] = set_elf_sym(s, sym->st_value, sym->st_size, sym->st_info,
              sym->st_other, sym->st_shndx, (char*)s->link->data + sym->st_name);
      }
--- 174,183 ----
      for (i = 0; i < nb_syms; ++i) {
          ElfSym *sym = (ElfSym*)s->data + first_sym + i;
          if (sym->st_shndx == SHN_UNDEF
!             && ELFW(ST_BIND)(sym->st_info) == STB_LOCAL) {
!             int tmp = ELFW(ST_TYPE)(sym->st_info);
!             sym->st_info = ELFW(ST_INFO)(STB_GLOBAL,tmp);
!         }
          tr[i] = set_elf_sym(s, sym->st_value, sym->st_size, sym->st_info,
              sym->st_other, sym->st_shndx, (char*)s->link->data + sym->st_name);
      }
***************
*** 187,194 ****
              ElfW_Rel *rel_end = (ElfW_Rel*)(sr->data + sr->data_offset);
              for (; rel < rel_end; ++rel) {
                  int n = ELFW(R_SYM)(rel->r_info) - first_sym;
!                 //if (n < 0) tcc_error("internal: invalid symbol index in relocation");
!                 rel->r_info = ELFW(R_INFO)(tr[n], ELFW(R_TYPE)(rel->r_info));
              }
          }
      }
--- 189,197 ----
              ElfW_Rel *rel_end = (ElfW_Rel*)(sr->data + sr->data_offset);
              for (; rel < rel_end; ++rel) {
                  int n = ELFW(R_SYM)(rel->r_info) - first_sym;
!                 /* //if (n < 0) tcc_error("internal: invalid symbol index in relocation"); */
!                 int tmp = ELFW(R_TYPE)(rel->r_info);
!                 rel->r_info = ELFW(R_INFO)(tr[n], tmp);
              }
          }
      }
***************
*** 1105,1111 ****
  
      sym = &((ElfW(Sym) *) symtab_section->data)[sym_index];
      name = (char *) symtab_section->link->data + sym->st_name;
!     //printf("sym %d %s\n", need_plt_entry, name);
  
      if (s1->dynsym) {
  	if (ELFW(ST_BIND)(sym->st_info) == STB_LOCAL) {
--- 1108,1114 ----
  
      sym = &((ElfW(Sym) *) symtab_section->data)[sym_index];
      name = (char *) symtab_section->link->data + sym->st_name;
!     /* //printf("sym %d %s\n", need_plt_entry, name); */
  
      if (s1->dynsym) {
  	if (ELFW(ST_BIND)(sym->st_info) == STB_LOCAL) {
***************
*** 1509,1515 ****
          }
  #endif
  #if defined TCC_TARGET_ARM && TARGETOS_FreeBSD
!         tcc_add_library_err(s1, "gcc_s"); // unwind code
  #endif
          if (TCC_LIBTCC1[0])
              tcc_add_support(s1, TCC_LIBTCC1);
--- 1512,1518 ----
          }
  #endif
  #if defined TCC_TARGET_ARM && TARGETOS_FreeBSD
!         tcc_add_library_err(s1, "gcc_s"); /* // unwind code */
  #endif
          if (TCC_LIBTCC1[0])
              tcc_add_support(s1, TCC_LIBTCC1);
***************
*** 1861,1867 ****
          unsigned long data_offset;
          addr_t rel_addr;
          addr_t rel_size;
!     };
  
      ElfW(Phdr) *phdr;
      int phnum;
--- 1864,1870 ----
          unsigned long data_offset;
          addr_t rel_addr;
          addr_t rel_size;
!     } a;
  
      ElfW(Phdr) *phdr;
      int phnum;
***************
*** 1963,1969 ****
                  f0 = f, ++n, f |= 1<<8;
          }
          sec_cls[i] = f;
!         //printf("ph %d sec %02d : %3X %3X  %8.2X  %04X  %s\n", !!f * n, i, f, k, s->sh_type, s->sh_size, s->name);
      }
      return n;
  }
--- 1966,1972 ----
                  f0 = f, ++n, f |= 1<<8;
          }
          sec_cls[i] = f;
!         /* //printf("ph %d sec %02d : %3X %3X  %8.2X  %04X  %s\n", !!f * n, i, f, k, s->sh_type, s->sh_size, s->name); */
      }
      return n;
  }
***************
*** 2169,2176 ****
      }
      put_dt(dynamic, DT_RELACOUNT, 0);
  #else
!     put_dt(dynamic, DT_REL, dyninf->rel_addr);
!     put_dt(dynamic, DT_RELSZ, dyninf->rel_size);
      put_dt(dynamic, DT_RELENT, sizeof(ElfW_Rel));
      if (s1->plt && s1->plt->reloc) {
          put_dt(dynamic, DT_PLTGOT, s1->got->sh_addr);
--- 2172,2179 ----
      }
      put_dt(dynamic, DT_RELACOUNT, 0);
  #else
!     put_dt(dynamic, DT_REL, dyninf->a.rel_addr);
!     put_dt(dynamic, DT_RELSZ, dyninf->a.rel_size);
      put_dt(dynamic, DT_RELENT, sizeof(ElfW_Rel));
      if (s1->plt && s1->plt->reloc) {
          put_dt(dynamic, DT_PLTGOT, s1->got->sh_addr);
***************
*** 2227,2246 ****
      Section *relocplt = s1->plt ? s1->plt->reloc : NULL;
  
      /* dynamic relocation table information, for .dynamic section */
!     dyninf->rel_addr = dyninf->rel_size = 0;
  
      for(i = 1; i < s1->nb_sections; i++) {
          s = s1->sections[i];
  	if (s->sh_type == SHT_RELX && s != relocplt) {
! 	    if (dyninf->rel_size == 0) {
! 		dyninf->rel_addr = s->sh_addr;
  		file_offset = s->sh_offset;
  	    }
  	    else {
! 		s->sh_addr = dyninf->rel_addr + dyninf->rel_size;
! 		s->sh_offset = file_offset + dyninf->rel_size;
  	    }
! 	    dyninf->rel_size += s->sh_size;
  	}
      }
  }
--- 2230,2249 ----
      Section *relocplt = s1->plt ? s1->plt->reloc : NULL;
  
      /* dynamic relocation table information, for .dynamic section */
!     dyninf->a.rel_addr = dyninf->a.rel_size = 0;
  
      for(i = 1; i < s1->nb_sections; i++) {
          s = s1->sections[i];
  	if (s->sh_type == SHT_RELX && s != relocplt) {
! 	    if (dyninf->a.rel_size == 0) {
! 		dyninf->a.rel_addr = s->sh_addr;
  		file_offset = s->sh_offset;
  	    }
  	    else {
! 		s->sh_addr = dyninf->a.rel_addr + dyninf->a.rel_size;
! 		s->sh_offset = file_offset + dyninf->a.rel_size;
  	    }
! 	    dyninf->a.rel_size += s->sh_size;
  	}
      }
  }
***************
*** 2473,2507 ****
  #ifdef TCC_TARGET_ARM
  static void create_arm_attribute_section(TCCState *s1)
  {
!    // Needed for DLL support.
      static const unsigned char arm_attr[] = {
!         0x41,                            // 'A'
!         0x2c, 0x00, 0x00, 0x00,          // size 0x2c
!         'a', 'e', 'a', 'b', 'i', 0x00,   // "aeabi"
!         0x01, 0x22, 0x00, 0x00, 0x00,    // 'File Attributes', size 0x22
!         0x05, 0x36, 0x00,                // 'CPU_name', "6"
!         0x06, 0x06,                      // 'CPU_arch', 'v6'
!         0x08, 0x01,                      // 'ARM_ISA_use', 'Yes'
!         0x09, 0x01,                      // 'THUMB_ISA_use', 'Thumb-1'
!         0x0a, 0x02,                      // 'FP_arch', 'VFPv2'
!         0x12, 0x04,                      // 'ABI_PCS_wchar_t', 4
!         0x14, 0x01,                      // 'ABI_FP_denormal', 'Needed'
!         0x15, 0x01,                      // 'ABI_FP_exceptions', 'Needed'
!         0x17, 0x03,                      // 'ABI_FP_number_model', 'IEEE 754'
!         0x18, 0x01,                      // 'ABI_align_needed', '8-byte'
!         0x19, 0x01,                      // 'ABI_align_preserved', '8-byte, except leaf SP'
!         0x1a, 0x02,                      // 'ABI_enum_size', 'int'
!         0x1c, 0x01,                      // 'ABI_VFP_args', 'VFP registers'
!         0x22, 0x01                       // 'CPU_unaligned_access', 'v6'
      };
      Section *attr = new_section(s1, ".ARM.attributes", SHT_ARM_ATTRIBUTES, 0);
      unsigned char *ptr = section_ptr_add(attr, sizeof(arm_attr));
      attr->sh_addralign = 1;
      memcpy(ptr, arm_attr, sizeof(arm_attr));
      if (s1->float_abi != ARM_HARD_FLOAT) {
!         ptr[26] = 0x00; // 'FP_arch', 'No'
!         ptr[41] = 0x1e; // 'ABI_optimization_goals'
!         ptr[42] = 0x06; // 'Aggressive Debug'
      }
  }
  #endif
--- 2476,2510 ----
  #ifdef TCC_TARGET_ARM
  static void create_arm_attribute_section(TCCState *s1)
  {
!    /* // Needed for DLL support. */
      static const unsigned char arm_attr[] = {
!         0x41,                            /* // 'A' */
!         0x2c, 0x00, 0x00, 0x00,          /* // size 0x2c */
!         'a', 'e', 'a', 'b', 'i', 0x00,   /* // "aeabi" */
!         0x01, 0x22, 0x00, 0x00, 0x00,    /* // 'File Attributes', size 0x22 */
!         0x05, 0x36, 0x00,                /* // 'CPU_name', "6" */
!         0x06, 0x06,                      /* // 'CPU_arch', 'v6' */
!         0x08, 0x01,                      /* // 'ARM_ISA_use', 'Yes' */
!         0x09, 0x01,                      /* // 'THUMB_ISA_use', 'Thumb-1' */
!         0x0a, 0x02,                      /* // 'FP_arch', 'VFPv2' */
!         0x12, 0x04,                      /* // 'ABI_PCS_wchar_t', 4 */
!         0x14, 0x01,                      /* // 'ABI_FP_denormal', 'Needed' */
!         0x15, 0x01,                      /* // 'ABI_FP_exceptions', 'Needed' */
!         0x17, 0x03,                      /* // 'ABI_FP_number_model', 'IEEE 754' */
!         0x18, 0x01,                      /* // 'ABI_align_needed', '8-byte' */
!         0x19, 0x01,                      /* // 'ABI_align_preserved', '8-byte, except leaf SP' */
!         0x1a, 0x02,                      /* // 'ABI_enum_size', 'int' */
!         0x1c, 0x01,                      /* // 'ABI_VFP_args', 'VFP registers' */
!         0x22, 0x01                       /* // 'CPU_unaligned_access', 'v6' */
      };
      Section *attr = new_section(s1, ".ARM.attributes", SHT_ARM_ATTRIBUTES, 0);
      unsigned char *ptr = section_ptr_add(attr, sizeof(arm_attr));
      attr->sh_addralign = 1;
      memcpy(ptr, arm_attr, sizeof(arm_attr));
      if (s1->float_abi != ARM_HARD_FLOAT) {
!         ptr[26] = 0x00; /* // 'FP_arch', 'No' */
!         ptr[41] = 0x1e; /* // 'ABI_optimization_goals' */
!         ptr[42] = 0x06; /* // 'Aggressive Debug' */
      }
  }
  #endif
***************
*** 2644,2650 ****
          dyninf.dynamic = dynamic;
          dyninf.dynstr = dynstr;
          /* remember offset and reserve space for 2nd call below */
!         dyninf.data_offset = dynamic->data_offset;
          fill_dynamic(s1, &dyninf);
          dynamic->sh_size = dynamic->data_offset;
          dynstr->sh_size = dynstr->data_offset;
--- 2647,2653 ----
          dyninf.dynamic = dynamic;
          dyninf.dynstr = dynstr;
          /* remember offset and reserve space for 2nd call below */
!         dyninf.a.data_offset = dynamic->data_offset;
          fill_dynamic(s1, &dyninf);
          dynamic->sh_size = dynamic->data_offset;
          dynstr->sh_size = dynstr->data_offset;
***************
*** 2681,2687 ****
          relocate_sections(s1);
          if (dynamic) {
  	    update_reloc_sections (s1, &dyninf);
!             dynamic->data_offset = dyninf.data_offset;
              fill_dynamic(s1, &dyninf);
  	}
          /* Perform relocation to GOT or PLT entries */
--- 2684,2690 ----
          relocate_sections(s1);
          if (dynamic) {
  	    update_reloc_sections (s1, &dyninf);
!             dynamic->data_offset = dyninf.a.data_offset;
              fill_dynamic(s1, &dyninf);
  	}
          /* Perform relocation to GOT or PLT entries */
diff -r -N -c a/tccgen.c b/tccgen.c
*** a/tccgen.c	2022-08-18 09:34:36.000000000 +0000
--- b/tccgen.c	2023-02-02 09:51:13.627305978 +0000
***************
*** 117,123 ****
  #define MAX_TEMP_LOCAL_VARIABLE_NUMBER 8
  /*list of temporary local variables on the stack in current function. */
  static struct temp_local_variable {
! 	int location; //offset on stack. Svalue.c.i
  	short size;
  	short align;
  } arr_temp_local_vars[MAX_TEMP_LOCAL_VARIABLE_NUMBER];
--- 117,123 ----
  #define MAX_TEMP_LOCAL_VARIABLE_NUMBER 8
  /*list of temporary local variables on the stack in current function. */
  static struct temp_local_variable {
! 	int location; /* //offset on stack. Svalue.c.i */
  	short size;
  	short align;
  } arr_temp_local_vars[MAX_TEMP_LOCAL_VARIABLE_NUMBER];
***************
*** 343,350 ****
  
      func_old_type.t = VT_FUNC;
      func_old_type.ref = sym_push(SYM_FIELD, &int_type, 0, 0);
!     func_old_type.ref->f.func_call = FUNC_CDECL;
!     func_old_type.ref->f.func_type = FUNC_OLD;
  #ifdef precedence_parser
      init_prec();
  #endif
--- 343,350 ----
  
      func_old_type.t = VT_FUNC;
      func_old_type.ref = sym_push(SYM_FIELD, &int_type, 0, 0);
!     func_old_type.ref->b.a.a.f.func_call = FUNC_CDECL;
!     func_old_type.ref->b.a.a.f.func_type = FUNC_OLD;
  #ifdef precedence_parser
      init_prec();
  #endif
***************
*** 397,405 ****
  /* ------------------------------------------------------------------------- */
  ST_FUNC ElfSym *elfsym(Sym *s)
  {
!   if (!s || !s->c)
      return NULL;
!   return &((ElfSym *)symtab_section->data)[s->c];
  }
  
  /* apply storage attributes to Elf symbol */
--- 397,405 ----
  /* ------------------------------------------------------------------------- */
  ST_FUNC ElfSym *elfsym(Sym *s)
  {
!   if (s == NULL || s->b.a.c == 0)
      return NULL;
!   return &((ElfSym *)symtab_section->data)[s->b.a.c];
  }
  
  /* apply storage attributes to Elf symbol */
***************
*** 424,430 ****
          sym_bind = STB_GLOBAL;
      old_sym_bind = ELFW(ST_BIND)(esym->st_info);
      if (sym_bind != old_sym_bind) {
!         esym->st_info = ELFW(ST_INFO)(sym_bind, ELFW(ST_TYPE)(esym->st_info));
      }
  
  #ifdef TCC_TARGET_PE
--- 424,431 ----
          sym_bind = STB_GLOBAL;
      old_sym_bind = ELFW(ST_BIND)(esym->st_info);
      if (sym_bind != old_sym_bind) {
!         int tmp = ELFW(ST_TYPE)(esym->st_info);
!         esym->st_info = ELFW(ST_INFO)(sym_bind, tmp);
      }
  
  #ifdef TCC_TARGET_PE
***************
*** 458,464 ****
      const char *name;
      char buf1[256];
  
!     if (!sym->c) {
          name = get_tok_str(sym->v, NULL);
          t = sym->type.t;
          if ((t & VT_BTYPE) == VT_FUNC) {
--- 459,465 ----
      const char *name;
      char buf1[256];
  
!     if (!sym->b.a.c) {
          name = get_tok_str(sym->v, NULL);
          t = sym->type.t;
          if ((t & VT_BTYPE) == VT_FUNC) {
***************
*** 491,498 ****
          }
  #endif
  
!         if (sym->asm_label) {
!             name = get_tok_str(sym->asm_label, NULL);
              can_add_underscore = 0;
          }
  
--- 492,499 ----
          }
  #endif
  
!         if (sym->e.asm_label) {
!             name = get_tok_str(sym->e.asm_label, NULL);
              can_add_underscore = 0;
          }
  
***************
*** 503,509 ****
          }
  
          info = ELFW(ST_INFO)(sym_bind, sym_type);
!         sym->c = put_elf_sym(symtab_section, value, size, info, other, sh_num, name);
  
          if (debug_modes)
              tcc_debug_extern_sym(tcc_state, sym, sh_num, sym_bind, sym_type);
--- 504,510 ----
          }
  
          info = ELFW(ST_INFO)(sym_bind, sym_type);
!         sym->b.a.c = put_elf_sym(symtab_section, value, size, info, other, sh_num, name);
  
          if (debug_modes)
              tcc_debug_extern_sym(tcc_state, sym, sh_num, sym_bind, sym_type);
***************
*** 534,542 ****
          return;
  
      if (sym) {
!         if (0 == sym->c)
              put_extern_sym(sym, NULL, 0, 0);
!         c = sym->c;
      }
  
      /* now we can add ELF relocation info */
--- 535,543 ----
          return;
  
      if (sym) {
!         if (0 == sym->b.a.c)
              put_extern_sym(sym, NULL, 0, 0);
!         c = sym->b.a.c;
      }
  
      /* now we can add ELF relocation info */
***************
*** 563,569 ****
      last_sym = sym_free_first;
      sym = sym_pool;
      for(i = 0; i < SYM_POOL_NB; i++) {
!         sym->next = last_sym;
          last_sym = sym;
          sym++;
      }
--- 564,570 ----
      last_sym = sym_free_first;
      sym = sym_pool;
      for(i = 0; i < SYM_POOL_NB; i++) {
!         sym->e.next = last_sym;
          last_sym = sym;
          sym++;
      }
***************
*** 578,584 ****
      sym = sym_free_first;
      if (!sym)
          sym = __sym_malloc();
!     sym_free_first = sym->next;
      return sym;
  #else
      sym = tcc_malloc(sizeof(Sym));
--- 579,585 ----
      sym = sym_free_first;
      if (!sym)
          sym = __sym_malloc();
!     sym_free_first = sym->e.next;
      return sym;
  #else
      sym = tcc_malloc(sizeof(Sym));
***************
*** 589,595 ****
  ST_INLN void sym_free(Sym *sym)
  {
  #ifndef SYM_DEBUG
!     sym->next = sym_free_first;
      sym_free_first = sym;
  #else
      tcc_free(sym);
--- 590,596 ----
  ST_INLN void sym_free(Sym *sym)
  {
  #ifndef SYM_DEBUG
!     sym->e.next = sym_free_first;
      sym_free_first = sym;
  #else
      tcc_free(sym);
***************
*** 605,611 ****
      memset(s, 0, sizeof *s);
      s->v = v;
      s->type.t = t;
!     s->c = c;
      /* add in stack */
      s->prev = *ps;
      *ps = s;
--- 606,612 ----
      memset(s, 0, sizeof *s);
      s->v = v;
      s->type.t = t;
!     s->b.a.c = c;
      /* add in stack */
      s->prev = *ps;
      *ps = s;
***************
*** 647,655 ****
  static int sym_scope(Sym *s)
  {
    if (IS_ENUM_VAL (s->type.t))
!     return s->type.ref->sym_scope;
    else
!     return s->sym_scope;
  }
  
  /* push a given symbol on the symbol stack */
--- 648,656 ----
  static int sym_scope(Sym *s)
  {
    if (IS_ENUM_VAL (s->type.t))
!     return s->type.ref->b.a.a.sym_scope;
    else
!     return s->b.a.a.sym_scope;
  }
  
  /* push a given symbol on the symbol stack */
***************
*** 676,683 ****
              ps = &ts->sym_identifier;
          s->prev_tok = *ps;
          *ps = s;
!         s->sym_scope = local_scope;
!         if (s->prev_tok && sym_scope(s->prev_tok) == s->sym_scope)
              tcc_error("redeclaration of '%s'",
                  get_tok_str(v & ~SYM_STRUCT, NULL));
      }
--- 677,684 ----
              ps = &ts->sym_identifier;
          s->prev_tok = *ps;
          *ps = s;
!         s->b.a.a.sym_scope = local_scope;
!         if (s->prev_tok && sym_scope(s->prev_tok) == s->b.a.a.sym_scope)
              tcc_error("redeclaration of '%s'",
                  get_tok_str(v & ~SYM_STRUCT, NULL));
      }
***************
*** 694,701 ****
      if (v < SYM_FIRST_ANOM) {
          ps = &table_ident[v - TOK_IDENT]->sym_identifier;
          /* modify the top most local identifier, so that sym_identifier will
!            point to 's' when popped; happens when called from inline asm */
!         while (*ps != NULL && (*ps)->sym_scope)
              ps = &(*ps)->prev_tok;
          s->prev_tok = *ps;
          *ps = s;
--- 695,702 ----
      if (v < SYM_FIRST_ANOM) {
          ps = &table_ident[v - TOK_IDENT]->sym_identifier;
          /* modify the top most local identifier, so that sym_identifier will
!            point to 's' when popped; happens when called from asm */
!         while (*ps != NULL && (*ps)->b.a.a.sym_scope)
              ps = &(*ps)->prev_tok;
          s->prev_tok = *ps;
          *ps = s;
***************
*** 761,768 ****
      vtop->type = *type;
      vtop->r = r;
      vtop->r2 = VT_CONST;
!     vtop->c = *vc;
!     vtop->sym = NULL;
  }
  
  ST_FUNC void vswap(void)
--- 762,769 ----
      vtop->type = *type;
      vtop->r = r;
      vtop->r2 = VT_CONST;
!     vtop->a.c = *vc;
!     vtop->b.sym = NULL;
  }
  
  ST_FUNC void vswap(void)
***************
*** 788,795 ****
  #endif
      if (v == VT_CMP) {
          /* need to put correct jump if && or || without test */
!         gsym(vtop->jtrue);
!         gsym(vtop->jfalse);
      }
      vtop--;
  }
--- 789,796 ----
  #endif
      if (v == VT_CMP) {
          /* need to put correct jump if && or || without test */
!         gsym(vtop->a.a.jtrue);
!         gsym(vtop->a.a.jfalse);
      }
      vtop--;
  }
***************
*** 902,924 ****
  ST_FUNC void vset_VT_CMP(int op)
  {
      vtop->r = VT_CMP;
!     vtop->cmp_op = op;
!     vtop->jfalse = 0;
!     vtop->jtrue = 0;
  }
  
  /* called once before asking generators to load VT_CMP to a register */
  static void vset_VT_JMP(void)
  {
!     int op = vtop->cmp_op;
  
!     if (vtop->jtrue || vtop->jfalse) {
          /* we need to jump to 'mov $0,%R' or 'mov $1,%R' */
          int inv = op & (op < 2); /* small optimization */
          vseti(VT_JMP+inv, gvtst(inv, 0));
      } else {
          /* otherwise convert flags (rsp. 0/1) to register */
!         vtop->c.i = op;
          if (op < 2) /* doesn't seem to happen */
              vtop->r = VT_CONST;
      }
--- 903,925 ----
  ST_FUNC void vset_VT_CMP(int op)
  {
      vtop->r = VT_CMP;
!     vtop->b.b.cmp_op = op;
!     vtop->a.a.jfalse = 0;
!     vtop->a.a.jtrue = 0;
  }
  
  /* called once before asking generators to load VT_CMP to a register */
  static void vset_VT_JMP(void)
  {
!     int op = vtop->b.b.cmp_op;
  
!     if (vtop->a.a.jtrue || vtop->a.a.jfalse) {
          /* we need to jump to 'mov $0,%R' or 'mov $1,%R' */
          int inv = op & (op < 2); /* small optimization */
          vseti(VT_JMP+inv, gvtst(inv, 0));
      } else {
          /* otherwise convert flags (rsp. 0/1) to register */
!         vtop->a.c.i = op;
          if (op < 2) /* doesn't seem to happen */
              vtop->r = VT_CONST;
      }
***************
*** 933,942 ****
          vpushi(0);
          gen_op(TOK_NE);
          if (vtop->r != VT_CMP) /* must be VT_CONST then */
!             vset_VT_CMP(vtop->c.i != 0);
      }
  
!     p = inv ? &vtop->jfalse : &vtop->jtrue;
      *p = gjmp_append(*p, t);
  }
  
--- 934,943 ----
          vpushi(0);
          gen_op(TOK_NE);
          if (vtop->r != VT_CMP) /* must be VT_CONST then */
!             vset_VT_CMP(vtop->a.c.i != 0);
      }
  
!     p = inv ? &vtop->a.a.jfalse : &vtop->a.a.jtrue;
      *p = gjmp_append(*p, t);
  }
  
***************
*** 948,957 ****
      int op, x, u;
  
      gvtst_set(inv, t);
!     t = vtop->jtrue, u = vtop->jfalse;
      if (inv)
          x = u, u = t, t = x;
!     op = vtop->cmp_op;
  
      /* jump to the wanted target */
      if (op > 1)
--- 949,958 ----
      int op, x, u;
  
      gvtst_set(inv, t);
!     t = vtop->a.a.jtrue, u = vtop->a.a.jfalse;
      if (inv)
          x = u, u = t, t = x;
!     op = vtop->b.b.cmp_op;
  
      /* jump to the wanted target */
      if (op > 1)
***************
*** 971,980 ****
      if (vtop->r == VT_CMP) {
          int j;
          if (op == TOK_EQ) {
!             j = vtop->jfalse;
!             vtop->jfalse = vtop->jtrue;
!             vtop->jtrue = j;
!             vtop->cmp_op ^= 1;
          }
      } else {
          vpushi(0);
--- 972,981 ----
      if (vtop->r == VT_CMP) {
          int j;
          if (op == TOK_EQ) {
!             j = vtop->a.a.jfalse;
!             vtop->a.a.jfalse = vtop->a.a.jtrue;
!             vtop->a.a.jtrue = j;
!             vtop->b.b.cmp_op ^= 1;
          }
      } else {
          vpushi(0);
***************
*** 989,995 ****
      CValue cval;
      cval.i = 0;
      vsetc(type, VT_CONST | VT_SYM, &cval);
!     vtop->sym = sym;
  }
  
  /* Return a static symbol pointing to a section */
--- 990,996 ----
      CValue cval;
      cval.i = 0;
      vsetc(type, VT_CONST | VT_SYM, &cval);
!     vtop->b.sym = sym;
  }
  
  /* Return a static symbol pointing to a section */
***************
*** 1133,1156 ****
          }
  
          if (0 == (type->t & VT_EXTERN)) {
!             struct FuncAttr f = sym->type.ref->f;
              /* put complete type, use static from prototype */
              sym->type.t = (type->t & ~(VT_STATIC|VT_INLINE)) | static_proto;
              sym->type.ref = type->ref;
!             merge_funcattr(&sym->type.ref->f, &f);
          } else {
              sym->type.t &= ~VT_INLINE | static_proto;
          }
  
!         if (sym->type.ref->f.func_type == FUNC_OLD
!              && type->ref->f.func_type != FUNC_OLD) {
              sym->type.ref = type->ref;
          }
  
      } else {
!         if ((sym->type.t & VT_ARRAY) && type->ref->c >= 0) {
              /* set array size if it was omitted in extern declaration */
!             sym->type.ref->c = type->ref->c;
          }
          if ((type->t ^ sym->type.t) & VT_STATIC)
              tcc_warning("storage mismatch for redefinition of '%s'",
--- 1134,1157 ----
          }
  
          if (0 == (type->t & VT_EXTERN)) {
!             struct FuncAttr f = sym->type.ref->b.a.a.f;
              /* put complete type, use static from prototype */
              sym->type.t = (type->t & ~(VT_STATIC|VT_INLINE)) | static_proto;
              sym->type.ref = type->ref;
!             merge_funcattr(&sym->type.ref->b.a.a.f, &f);
          } else {
              sym->type.t &= ~VT_INLINE | static_proto;
          }
  
!         if (sym->type.ref->b.a.a.f.func_type == FUNC_OLD
!              && type->ref->b.a.a.f.func_type != FUNC_OLD) {
              sym->type.ref = type->ref;
          }
  
      } else {
!         if ((sym->type.t & VT_ARRAY) && type->ref->b.a.c >= 0) {
              /* set array size if it was omitted in extern declaration */
!             sym->type.ref->b.a.c = type->ref->b.a.c;
          }
          if ((type->t ^ sym->type.t) & VT_STATIC)
              tcc_warning("storage mismatch for redefinition of '%s'",
***************
*** 1171,1177 ****
  #endif
      merge_symattr(&sym->a, &ad->a);
      if (ad->asm_label)
!         sym->asm_label = ad->asm_label;
      update_storage(sym);
  }
  
--- 1172,1178 ----
  #endif
      merge_symattr(&sym->a, &ad->a);
      if (ad->asm_label)
!         sym->e.asm_label = ad->asm_label;
      update_storage(sym);
  }
  
***************
*** 1192,1202 ****
  static void sym_copy_ref(Sym *s, Sym **ps)
  {
      int bt = s->type.t & VT_BTYPE;
!     if (bt == VT_FUNC || bt == VT_PTR || (bt == VT_STRUCT && s->sym_scope)) {
          Sym **sp = &s->type.ref;
!         for (s = *sp, *sp = NULL; s; s = s->next) {
              Sym *s2 = sym_copy(s, ps);
!             sp = &(*sp = s2)->next;
              sym_copy_ref(s2, ps);
          }
      }
--- 1193,1203 ----
  static void sym_copy_ref(Sym *s, Sym **ps)
  {
      int bt = s->type.t & VT_BTYPE;
!     if (bt == VT_FUNC || bt == VT_PTR || (bt == VT_STRUCT && s->b.a.a.sym_scope)) {
          Sym **sp = &s->type.ref;
!         for (s = *sp, *sp = NULL; s; s = s->e.next) {
              Sym *s2 = sym_copy(s, ps);
!             sp = &(*sp = s2)->e.next;
              sym_copy_ref(s2, ps);
          }
      }
***************
*** 1209,1215 ****
  
      /* look for global symbol */
      s = sym_find(v);
!     while (s && s->sym_scope)
          s = s->prev_tok;
  
      if (!s) {
--- 1210,1216 ----
  
      /* look for global symbol */
      s = sym_find(v);
!     while (s && s->b.a.a.sym_scope)
          s = s->prev_tok;
  
      if (!s) {
***************
*** 1217,1223 ****
          s = global_identifier_push(v, type->t, 0);
          s->r |= r;
          s->a = ad->a;
!         s->asm_label = ad->asm_label;
          s->type.ref = type->ref;
          /* copy type to the global stack */
          if (local_stack)
--- 1218,1224 ----
          s = global_identifier_push(v, type->t, 0);
          s->r |= r;
          s->a = ad->a;
!         s->e.asm_label = ad->asm_label;
          s->type.ref = type->ref;
          /* copy type to the global stack */
          if (local_stack)
***************
*** 1270,1276 ****
                  size = type_size(&sv.type, &align);
                  l = get_temp_local_var(size,align);
                  sv.r = VT_LOCAL | VT_LVAL;
!                 sv.c.i = l;
                  store(p->r & VT_VALMASK, &sv);
  #if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)
                  /* x86 specific: need to pop fp register ST0 if saved */
--- 1271,1277 ----
                  size = type_size(&sv.type, &align);
                  l = get_temp_local_var(size,align);
                  sv.r = VT_LOCAL | VT_LVAL;
!                 sv.a.c.i = l;
                  store(p->r & VT_VALMASK, &sv);
  #if defined(TCC_TARGET_I386) || defined(TCC_TARGET_X86_64)
                  /* x86 specific: need to pop fp register ST0 if saved */
***************
*** 1280,1286 ****
  #endif
                  /* special long long case */
                  if (p->r2 < VT_CONST && USING_TWO_WORDS(bt)) {
!                     sv.c.i += PTR_SIZE;
                      store(p->r2, &sv);
                  }
              }
--- 1281,1287 ----
  #endif
                  /* special long long case */
                  if (p->r2 < VT_CONST && USING_TWO_WORDS(bt)) {
!                     sv.a.c.i += PTR_SIZE;
                      store(p->r2, &sv);
                  }
              }
***************
*** 1293,1301 ****
              } else {
                  p->r = VT_LVAL | VT_LOCAL;
              }
!             p->sym = NULL;
              p->r2 = VT_CONST;
!             p->c.i = l;
          }
      }
  }
--- 1294,1302 ----
              } else {
                  p->r = VT_LVAL | VT_LOCAL;
              }
!             p->b.sym = NULL;
              p->r2 = VT_CONST;
!             p->a.c.i = l;
          }
      }
  }
***************
*** 1385,1391 ****
  		for(p=vstack;p<=vtop;p++) {
  			r=p->r&VT_VALMASK;
  			if(r==VT_LOCAL||r==VT_LLOCAL){
! 				if(p->c.i==temp_var->location){
  					free=0;
  					break;
  				}
--- 1386,1392 ----
  		for(p=vstack;p<=vtop;p++) {
  			r=p->r&VT_VALMASK;
  			if(r==VT_LOCAL||r==VT_LLOCAL){
! 				if(p->a.c.i==temp_var->location){
  					free=0;
  					break;
  				}
***************
*** 1426,1432 ****
          sv.type.t = t;
          sv.type.ref = NULL;
          sv.r = s;
!         sv.c.i = 0;
          load(r, &sv);
      }
  }
--- 1427,1433 ----
          sv.type.t = t;
          sv.type.ref = NULL;
          sv.r = s;
!         sv.a.c.i = 0;
          load(r, &sv);
      }
  }
***************
*** 1607,1630 ****
  {
      int n, o, bits;
      save_reg_upstack(vtop->r, 1);
!     vpush64(type->t & VT_BTYPE, 0); // B X
      bits = 0, o = bit_pos >> 3, bit_pos &= 7;
      do {
!         vswap(); // X B
          incr_bf_adr(o);
!         vdup(); // X B B
          n = 8 - bit_pos;
          if (n > bit_size)
              n = bit_size;
          if (bit_pos)
!             vpushi(bit_pos), gen_op(TOK_SHR), bit_pos = 0; // X B Y
          if (n < 8)
              vpushi((1 << n) - 1), gen_op('&');
          gen_cast(type);
          if (bits)
              vpushi(bits), gen_op(TOK_SHL);
!         vrotb(3); // B Y X
!         gen_op('|'); // B X
          bits += n, bit_size -= n, o = 1;
      } while (bit_size);
      vswap(), vpop();
--- 1608,1631 ----
  {
      int n, o, bits;
      save_reg_upstack(vtop->r, 1);
!     vpush64(type->t & VT_BTYPE, 0); /* // B X */
      bits = 0, o = bit_pos >> 3, bit_pos &= 7;
      do {
!         vswap(); /* // X B */
          incr_bf_adr(o);
!         vdup(); /* // X B B */
          n = 8 - bit_pos;
          if (n > bit_size)
              n = bit_size;
          if (bit_pos)
!             vpushi(bit_pos), gen_op(TOK_SHR), bit_pos = 0; /* // X B Y */
          if (n < 8)
              vpushi((1 << n) - 1), gen_op('&');
          gen_cast(type);
          if (bits)
              vpushi(bits), gen_op(TOK_SHL);
!         vrotb(3); /* // B Y X */
!         gen_op('|'); /* // B X */
          bits += n, bit_size -= n, o = 1;
      } while (bit_size);
      vswap(), vpop();
***************
*** 1640,1653 ****
  {
      int bits, n, o, m, c;
      c = (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
!     vswap(); // X B
      save_reg_upstack(vtop->r, 1);
      bits = 0, o = bit_pos >> 3, bit_pos &= 7;
      do {
!         incr_bf_adr(o); // X B
!         vswap(); //B X
!         c ? vdup() : gv_dup(); // B V X
!         vrott(3); // X B V
          if (bits)
              vpushi(bits), gen_op(TOK_SHR);
          if (bit_pos)
--- 1641,1654 ----
  {
      int bits, n, o, m, c;
      c = (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
!     vswap(); /* // X B */
      save_reg_upstack(vtop->r, 1);
      bits = 0, o = bit_pos >> 3, bit_pos &= 7;
      do {
!         incr_bf_adr(o); /* // X B */
!         vswap(); /* //B X */
!         c ? vdup() : gv_dup(); /* // B V X */
!         vrott(3); /* // X B V */
          if (bits)
              vpushi(bits), gen_op(TOK_SHR);
          if (bit_pos)
***************
*** 1657,1670 ****
              n = bit_size;
          if (n < 8) {
              m = ((1 << n) - 1) << bit_pos;
!             vpushi(m), gen_op('&'); // X B V1
!             vpushv(vtop-1); // X B V1 B
              vpushi(m & 0x80 ? ~m & 0x7f : ~m);
!             gen_op('&'); // X B V1 B1
!             gen_op('|'); // X B V2
          }
!         vdup(), vtop[-1] = vtop[-2]; // X B B V2
!         vstore(), vpop(); // X B
          bits += n, bit_size -= n, bit_pos = 0, o = 1;
      } while (bit_size);
      vpop(), vpop();
--- 1658,1671 ----
              n = bit_size;
          if (n < 8) {
              m = ((1 << n) - 1) << bit_pos;
!             vpushi(m), gen_op('&'); /* // X B V1 */
!             vpushv(vtop-1); /* // X B V1 B */
              vpushi(m & 0x80 ? ~m & 0x7f : ~m);
!             gen_op('&'); /* // X B V1 B1 */
!             gen_op('|'); /* // X B V2 */
          }
!         vdup(), vtop[-1] = vtop[-2]; /* // X B B V2 */
!         vstore(), vpop(); /* // X B */
          bits += n, bit_size -= n, bit_pos = 0, o = 1;
      } while (bit_size);
      vpop(), vpop();
***************
*** 1675,1681 ****
      int t;
      if (0 == sv->type.ref)
          return 0;
!     t = sv->type.ref->auxtype;
      if (t != -1 && t != VT_STRUCT) {
          sv->type.t = (sv->type.t & ~(VT_BTYPE | VT_LONG)) | t;
          sv->r |= VT_LVAL;
--- 1676,1682 ----
      int t;
      if (0 == sv->type.ref)
          return 0;
!     t = sv->type.ref->b.a.a.auxtype;
      if (t != -1 && t != VT_STRUCT) {
          sv->type.t = (sv->type.t & ~(VT_BTYPE | VT_LONG)) | t;
          sv->r |= VT_LVAL;
***************
*** 1731,1738 ****
              (vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {
              /* CPUs usually cannot use float constants, so we store them
                 generically in data segment */
!             init_params p = { rodata_section };
              unsigned long offset;
              size = type_size(&vtop->type, &align);
              if (NODATA_WANTED)
                  size = 0, align = 1;
--- 1732,1740 ----
              (vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {
              /* CPUs usually cannot use float constants, so we store them
                 generically in data segment */
!             init_params p;
              unsigned long offset;
+             p.sec = rodata_section;
              size = type_size(&vtop->type, &align);
              if (NODATA_WANTED)
                  size = 0, align = 1;
***************
*** 1775,1782 ****
                     expand to two words temporarily */
                  if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {
                      /* load constant */
!                     unsigned long long ll = vtop->c.i;
!                     vtop->c.i = ll; /* first word */
                      load(r, vtop);
                      vtop->r = r; /* save register value */
                      vpushi(ll >> 32); /* second word */
--- 1777,1784 ----
                     expand to two words temporarily */
                  if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST) {
                      /* load constant */
!                     unsigned long long ll = vtop->a.c.i;
!                     vtop->a.c.i = ll; /* first word */
                      load(r, vtop);
                      vtop->r = r; /* save register value */
                      vpushi(ll >> 32); /* second word */
***************
*** 1870,1879 ****
      v = vtop->r & (VT_VALMASK | VT_LVAL);
      if (v == VT_CONST) {
          vdup();
!         vtop[0].c.i >>= 32;
      } else if (v == (VT_LVAL|VT_CONST) || v == (VT_LVAL|VT_LOCAL)) {
          vdup();
!         vtop[0].c.i += 4;
      } else {
          gv(RC_INT);
          vdup();
--- 1872,1881 ----
      v = vtop->r & (VT_VALMASK | VT_LVAL);
      if (v == VT_CONST) {
          vdup();
!         vtop[0].a.c.i >>= 32;
      } else if (v == (VT_LVAL|VT_CONST) || v == (VT_LVAL|VT_LOCAL)) {
          vdup();
!         vtop[0].a.c.i += 4;
      } else {
          gv(RC_INT);
          vdup();
***************
*** 1976,1982 ****
      case '*':
      case '+':
      case '-':
!         //pv("gen_opl A",0,2);
          t = vtop->type.t;
          vswap();
          lexpand();
--- 1978,1984 ----
      case '*':
      case '+':
      case '-':
!         /* //pv("gen_opl A",0,2); */
          t = vtop->type.t;
          vswap();
          lexpand();
***************
*** 1991,1997 ****
          vtop[-3] = tmp;
          vswap();
          /* stack: H1 H2 L1 L2 */
!         //pv("gen_opl B",0,4);
          if (op == '*') {
              vpushv(vtop - 1);
              vpushv(vtop - 1);
--- 1993,1999 ----
          vtop[-3] = tmp;
          vswap();
          /* stack: H1 H2 L1 L2 */
!         /* //pv("gen_opl B",0,4); */
          if (op == '*') {
              vpushv(vtop - 1);
              vpushv(vtop - 1);
***************
*** 2044,2050 ****
              lexpand();
              vrotb(3);
              /* stack: L H shift */
!             c = (int)vtop->c.i;
              /* constant: simpler */
              /* NOTE: all comments are for SHL. the other cases are
                 done by swapping words */
--- 2046,2052 ----
              lexpand();
              vrotb(3);
              /* stack: L H shift */
!             c = (int)vtop->a.c.i;
              /* constant: simpler */
              /* NOTE: all comments are for SHL. the other cases are
                 done by swapping words */
***************
*** 2155,2161 ****
          else if (op1 == TOK_GE)
              op1 = TOK_UGE;
          gen_op(op1);
! #if 0//def TCC_TARGET_I386
          if (op == TOK_NE) { gsym(b); break; }
          if (op == TOK_EQ) { gsym(a); break; }
  #endif
--- 2157,2163 ----
          else if (op1 == TOK_GE)
              op1 = TOK_UGE;
          gen_op(op1);
! #if 0/* //def TCC_TARGET_I386 */
          if (op == TOK_NE) { gsym(b); break; }
          if (op == TOK_EQ) { gsym(a); break; }
  #endif
***************
*** 2188,2195 ****
      int c1 = (v1->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
      int c2 = (v2->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
      int nonconst = (v1->r | v2->r) & VT_NONCONST;
!     uint64_t l1 = c1 ? v1->c.i : 0;
!     uint64_t l2 = c2 ? v2->c.i : 0;
      int shm = (t1 == VT_LLONG) ? 63 : 31;
  
      if (t1 != VT_LLONG && (PTR_SIZE != 8 || t1 != VT_PTR))
--- 2190,2197 ----
      int c1 = (v1->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
      int c2 = (v2->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
      int nonconst = (v1->r | v2->r) & VT_NONCONST;
!     uint64_t l1 = c1 ? v1->a.c.i : 0;
!     uint64_t l2 = c2 ? v2->a.c.i : 0;
      int shm = (t1 == VT_LLONG) ? 63 : 31;
  
      if (t1 != VT_LLONG && (PTR_SIZE != 8 || t1 != VT_PTR))
***************
*** 2251,2257 ****
  	if (t1 != VT_LLONG && (PTR_SIZE != 8 || t1 != VT_PTR))
  	    l1 = ((uint32_t)l1 |
  		(v1->type.t & VT_UNSIGNED ? 0 : -(l1 & 0x80000000)));
!         v1->c.i = l1;
          vtop--;
      } else {
          nonconst = VT_NONCONST;
--- 2253,2259 ----
  	if (t1 != VT_LLONG && (PTR_SIZE != 8 || t1 != VT_PTR))
  	    l1 = ((uint32_t)l1 |
  		(v1->type.t & VT_UNSIGNED ? 0 : -(l1 & 0x80000000)));
!         v1->a.c.i = l1;
          vtop--;
      } else {
          nonconst = VT_NONCONST;
***************
*** 2259,2266 ****
          if (c1 && (op == '+' || op == '&' || op == '^' || 
                     op == '|' || op == '*' || op == TOK_EQ || op == TOK_NE)) {
              vswap();
!             c2 = c1; //c = c1, c1 = c2, c2 = c;
!             l2 = l1; //l = l1, l1 = l2, l2 = l;
          }
          if (!const_wanted &&
              c1 && ((l1 == 0 &&
--- 2261,2268 ----
          if (c1 && (op == '+' || op == '&' || op == '^' || 
                     op == '|' || op == '*' || op == TOK_EQ || op == TOK_NE)) {
              vswap();
!             c2 = c1; /* //c = c1, c1 = c2, c2 = c; */
!             l2 = l1; /* //l = l1, l1 = l2, l2 = l; */
          }
          if (!const_wanted &&
              c1 && ((l1 == 0 &&
***************
*** 2275,2281 ****
                            (l2 == 1 && (op == '%' || op == TOK_UMOD)))) {
              /* treat (x & 0), (x * 0), (x | -1) and (x % 1) as constant */
              if (l2 == 1)
!                 vtop->c.i = 0;
              vswap();
              vtop--;
          } else if (c2 && (((op == '*' || op == '/' || op == TOK_UDIV ||
--- 2277,2283 ----
                            (l2 == 1 && (op == '%' || op == TOK_UMOD)))) {
              /* treat (x & 0), (x * 0), (x | -1) and (x % 1) as constant */
              if (l2 == 1)
!                 vtop->a.c.i = 0;
              vswap();
              vtop--;
          } else if (c2 && (((op == '*' || op == '/' || op == TOK_UDIV ||
***************
*** 2296,2302 ****
                      l2 >>= 1;
                      n++;
                  }
!                 vtop->c.i = n;
                  if (op == '*')
                      op = TOK_SHL;
                  else if (op == TOK_PDIV)
--- 2298,2304 ----
                      l2 >>= 1;
                      n++;
                  }
!                 vtop->a.c.i = n;
                  if (op == '*')
                      op = TOK_SHL;
                  else if (op == TOK_PDIV)
***************
*** 2311,2323 ****
              /* symbol + constant case */
              if (op == '-')
                  l2 = -l2;
! 	    l2 += vtop[-1].c.i;
  	    /* The backends can't always deal with addends to symbols
  	       larger than +-1<<31.  Don't construct such.  */
  	    if ((int)l2 != l2)
  	        goto general_case;
              vtop--;
!             vtop->c.i = l2;
          } else {
          general_case:
                  /* call low level op generator */
--- 2313,2325 ----
              /* symbol + constant case */
              if (op == '-')
                  l2 = -l2;
! 	    l2 += vtop[-1].a.c.i;
  	    /* The backends can't always deal with addends to symbols
  	       larger than +-1<<31.  Don't construct such.  */
  	    if ((int)l2 != l2)
  	        goto general_case;
              vtop--;
!             vtop->a.c.i = l2;
          } else {
          general_case:
                  /* call low level op generator */
***************
*** 2386,2399 ****
      c2 = (v2->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
      if (c1 && c2) {
          if (v1->type.t == VT_FLOAT) {
!             f1 = v1->c.f;
!             f2 = v2->c.f;
          } else if (v1->type.t == VT_DOUBLE) {
!             f1 = v1->c.d;
!             f2 = v2->c.d;
          } else {
!             f1 = v1->c.ld;
!             f2 = v2->c.ld;
          }
          /* NOTE: we only do constant propagation if finite number (not
             NaN or infinity) (ANSI spec) */
--- 2388,2401 ----
      c2 = (v2->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST;
      if (c1 && c2) {
          if (v1->type.t == VT_FLOAT) {
!             f1 = v1->a.c.f;
!             f2 = v2->a.c.f;
          } else if (v1->type.t == VT_DOUBLE) {
!             f1 = v1->a.c.d;
!             f2 = v2->a.c.d;
          } else {
!             f1 = v1->a.c.ld;
!             f2 = v2->a.c.ld;
          }
          /* NOTE: we only do constant propagation if finite number (not
             NaN or infinity) (ANSI spec) */
***************
*** 2434,2444 ****
      unary_result:
          /* XXX: overflow test ? */
          if (v1->type.t == VT_FLOAT) {
!             v1->c.f = f1;
          } else if (v1->type.t == VT_DOUBLE) {
!             v1->c.d = f1;
          } else {
!             v1->c.ld = f1;
          }
      } else {
      general_case:
--- 2436,2446 ----
      unary_result:
          /* XXX: overflow test ? */
          if (v1->type.t == VT_FLOAT) {
!             v1->a.c.f = f1;
          } else if (v1->type.t == VT_DOUBLE) {
!             v1->a.c.d = f1;
          } else {
!             v1->a.c.ld = f1;
          }
      } else {
      general_case:
***************
*** 2548,2563 ****
              pstrcat(buf1, sizeof(buf1), ")");
          }
          pstrcat(buf1, buf_size, "(");
!         sa = s->next;
          while (sa != NULL) {
              char buf2[256];
              type_to_str(buf2, sizeof(buf2), &sa->type, NULL);
              pstrcat(buf1, sizeof(buf1), buf2);
!             sa = sa->next;
              if (sa)
                  pstrcat(buf1, sizeof(buf1), ", ");
          }
!         if (s->f.func_type == FUNC_ELLIPSIS)
              pstrcat(buf1, sizeof(buf1), ", ...");
          pstrcat(buf1, sizeof(buf1), ")");
          type_to_str(buf, buf_size, &s->type, buf1);
--- 2550,2565 ----
              pstrcat(buf1, sizeof(buf1), ")");
          }
          pstrcat(buf1, buf_size, "(");
!         sa = s->e.next;
          while (sa != NULL) {
              char buf2[256];
              type_to_str(buf2, sizeof(buf2), &sa->type, NULL);
              pstrcat(buf1, sizeof(buf1), buf2);
!             sa = sa->e.next;
              if (sa)
                  pstrcat(buf1, sizeof(buf1), ", ");
          }
!         if (s->b.a.a.f.func_type == FUNC_ELLIPSIS)
              pstrcat(buf1, sizeof(buf1), ", ...");
          pstrcat(buf1, sizeof(buf1), ")");
          type_to_str(buf, buf_size, &s->type, buf1);
***************
*** 2566,2574 ****
          s = type->ref;
          if (t & (VT_ARRAY|VT_VLA)) {
              if (varstr && '*' == *varstr)
!                 snprintf(buf1, sizeof(buf1), "(%s)[%d]", varstr, s->c);
              else
!                 snprintf(buf1, sizeof(buf1), "%s[%d]", varstr ? varstr : "", s->c);
              type_to_str(buf, buf_size, &s->type, buf1);
              goto no_var;
          }
--- 2568,2576 ----
          s = type->ref;
          if (t & (VT_ARRAY|VT_VLA)) {
              if (varstr && '*' == *varstr)
!                 snprintf(buf1, sizeof(buf1), "(%s)[%d]", varstr, s->b.a.c);
              else
!                 snprintf(buf1, sizeof(buf1), "%s[%d]", varstr ? varstr : "", s->b.a.c);
              type_to_str(buf, buf_size, &s->type, buf1);
              goto no_var;
          }
***************
*** 2615,2624 ****
  {
      if ((p->r & (VT_VALMASK | VT_LVAL | VT_SYM | VT_NONCONST)) != VT_CONST)
          return 0;
!     return ((p->type.t & VT_BTYPE) == VT_INT && (uint32_t)p->c.i == 0) ||
!         ((p->type.t & VT_BTYPE) == VT_LLONG && p->c.i == 0) ||
          ((p->type.t & VT_BTYPE) == VT_PTR &&
!          (PTR_SIZE == 4 ? (uint32_t)p->c.i == 0 : p->c.i == 0) &&
           ((pointed_type(&p->type)->t & VT_BTYPE) == VT_VOID) &&
           0 == (pointed_type(&p->type)->t & (VT_CONSTANT | VT_VOLATILE))
           );
--- 2617,2626 ----
  {
      if ((p->r & (VT_VALMASK | VT_LVAL | VT_SYM | VT_NONCONST)) != VT_CONST)
          return 0;
!     return ((p->type.t & VT_BTYPE) == VT_INT && (uint32_t)p->a.c.i == 0) ||
!         ((p->type.t & VT_BTYPE) == VT_LLONG && p->a.c.i == 0) ||
          ((p->type.t & VT_BTYPE) == VT_PTR &&
!          (PTR_SIZE == 4 ? (uint32_t)p->a.c.i == 0 : p->a.c.i == 0) &&
           ((pointed_type(&p->type)->t & VT_BTYPE) == VT_VOID) &&
           0 == (pointed_type(&p->type)->t & (VT_CONSTANT | VT_VOLATILE))
           );
***************
*** 2631,2649 ****
  
      s1 = type1->ref;
      s2 = type2->ref;
!     if (s1->f.func_call != s2->f.func_call)
          return 0;
!     if (s1->f.func_type != s2->f.func_type
!         && s1->f.func_type != FUNC_OLD
!         && s2->f.func_type != FUNC_OLD)
          return 0;
      for (;;) {
          if (!is_compatible_unqualified_types(&s1->type, &s2->type))
              return 0;
!         if (s1->f.func_type == FUNC_OLD || s2->f.func_type == FUNC_OLD )
              return 1;
!         s1 = s1->next;
!         s2 = s2->next;
          if (!s1)
              return !s2;
          if (!s2)
--- 2633,2651 ----
  
      s1 = type1->ref;
      s2 = type2->ref;
!     if (s1->b.a.a.f.func_call != s2->b.a.a.f.func_call)
          return 0;
!     if (s1->b.a.a.f.func_type != s2->b.a.a.f.func_type
!         && s1->b.a.a.f.func_type != FUNC_OLD
!         && s2->b.a.a.f.func_type != FUNC_OLD)
          return 0;
      for (;;) {
          if (!is_compatible_unqualified_types(&s1->type, &s2->type))
              return 0;
!         if (s1->b.a.a.f.func_type == FUNC_OLD || s2->b.a.a.f.func_type == FUNC_OLD )
              return 1;
!         s1 = s1->e.next;
!         s2 = s2->e.next;
          if (!s1)
              return !s2;
          if (!s2)
***************
*** 2676,2684 ****
          return 0;
  
      if ((t1 & VT_ARRAY)
!         && !(type1->ref->c < 0
!           || type2->ref->c < 0
!           || type1->ref->c == type2->ref->c))
              return 0;
  
      /* test more complicated cases */
--- 2678,2686 ----
          return 0;
  
      if ((t1 & VT_ARRAY)
!         && !(type1->ref->b.a.c < 0
!           || type2->ref->b.a.c < 0
!           || type1->ref->b.a.c == type2->ref->b.a.c))
              return 0;
  
      /* test more complicated cases */
***************
*** 2758,2764 ****
                    {
                      /* copy the pointer target symbol */
                      type.ref = sym_push(SYM_FIELD, &type.ref->type,
!                                         0, type.ref->c);
                      copied = 1;
                      pointed_type(&type)->t |= newquals;
                    }
--- 2760,2766 ----
                    {
                      /* copy the pointer target symbol */
                      type.ref = sym_push(SYM_FIELD, &type.ref->type,
!                                         0, type.ref->b.a.c);
                      copied = 1;
                      pointed_type(&type)->t |= newquals;
                    }
***************
*** 2766,2782 ****
                     pointers to completed ones if possible */
                  if (pt1->t & VT_ARRAY
                      && pt2->t & VT_ARRAY
!                     && pointed_type(&type)->ref->c < 0
!                     && (pt1->ref->c > 0 || pt2->ref->c > 0))
                    {
                      if (!copied)
                        type.ref = sym_push(SYM_FIELD, &type.ref->type,
!                                           0, type.ref->c);
                      pointed_type(&type)->ref =
                          sym_push(SYM_FIELD, &pointed_type(&type)->ref->type,
!                                  0, pointed_type(&type)->ref->c);
!                     pointed_type(&type)->ref->c =
!                         0 < pt1->ref->c ? pt1->ref->c : pt2->ref->c;
                    }
              }
          }
--- 2768,2784 ----
                     pointers to completed ones if possible */
                  if (pt1->t & VT_ARRAY
                      && pt2->t & VT_ARRAY
!                     && pointed_type(&type)->ref->b.a.c < 0
!                     && (pt1->ref->b.a.c > 0 || pt2->ref->b.a.c > 0))
                    {
                      if (!copied)
                        type.ref = sym_push(SYM_FIELD, &type.ref->type,
!                                           0, type.ref->b.a.c);
                      pointed_type(&type)->ref =
                          sym_push(SYM_FIELD, &pointed_type(&type)->ref->type,
!                                  0, pointed_type(&type)->ref->b.a.c);
!                     pointed_type(&type)->ref->b.a.c =
!                         0 < pt1->ref->b.a.c ? pt1->ref->b.a.c : pt2->ref->b.a.c;
                    }
              }
          }
***************
*** 2949,2955 ****
              vtop->type.t = t;
          }
      }
!     // Make sure that we have converted to an rvalue:
      if (vtop->r & VT_LVAL)
          gv(is_float(vtop->type.t & VT_BTYPE) ? RC_FLOAT : RC_INT);
  }
--- 2951,2957 ----
              vtop->type.t = t;
          }
      }
!     /* // Make sure that we have converted to an rvalue: */
      if (vtop->r & VT_LVAL)
          gv(is_float(vtop->type.t & VT_BTYPE) ? RC_FLOAT : RC_INT);
  }
***************
*** 3068,3117 ****
              /* constant case: we can do it now */
              /* XXX: in ISOC, cannot do it if error in convert */
              if (sbt == VT_FLOAT)
!                 vtop->c.ld = vtop->c.f;
              else if (sbt == VT_DOUBLE)
!                 vtop->c.ld = vtop->c.d;
  
              if (df) {
                  if (sbt_bt == VT_LLONG) {
!                     if ((sbt & VT_UNSIGNED) || !(vtop->c.i >> 63))
!                         vtop->c.ld = vtop->c.i;
                      else
!                         vtop->c.ld = -(long double)-vtop->c.i;
                  } else if(!sf) {
!                     if ((sbt & VT_UNSIGNED) || !(vtop->c.i >> 31))
!                         vtop->c.ld = (uint32_t)vtop->c.i;
                      else
!                         vtop->c.ld = -(long double)-(uint32_t)vtop->c.i;
                  }
  
                  if (dbt == VT_FLOAT)
!                     vtop->c.f = (float)vtop->c.ld;
                  else if (dbt == VT_DOUBLE)
!                     vtop->c.d = (double)vtop->c.ld;
              } else if (sf && dbt == VT_BOOL) {
!                 vtop->c.i = (vtop->c.ld != 0);
              } else {
                  if(sf)
!                     vtop->c.i = vtop->c.ld;
                  else if (sbt_bt == VT_LLONG || (PTR_SIZE == 8 && sbt == VT_PTR))
                      ;
                  else if (sbt & VT_UNSIGNED)
!                     vtop->c.i = (uint32_t)vtop->c.i;
                  else
!                     vtop->c.i = ((uint32_t)vtop->c.i | -(vtop->c.i & 0x80000000));
  
                  if (dbt_bt == VT_LLONG || (PTR_SIZE == 8 && dbt == VT_PTR))
                      ;
                  else if (dbt == VT_BOOL)
!                     vtop->c.i = (vtop->c.i != 0);
                  else {
                      uint32_t m = dbt_bt == VT_BYTE ? 0xff :
                                   dbt_bt == VT_SHORT ? 0xffff :
                                    0xffffffff;
!                     vtop->c.i &= m;
                      if (!(dbt & VT_UNSIGNED))
!                         vtop->c.i |= -(vtop->c.i & ((m >> 1) + 1));
                  }
              }
              goto done;
--- 3070,3119 ----
              /* constant case: we can do it now */
              /* XXX: in ISOC, cannot do it if error in convert */
              if (sbt == VT_FLOAT)
!                 vtop->a.c.ld = vtop->a.c.f;
              else if (sbt == VT_DOUBLE)
!                 vtop->a.c.ld = vtop->a.c.d;
  
              if (df) {
                  if (sbt_bt == VT_LLONG) {
!                     if ((sbt & VT_UNSIGNED) || !(vtop->a.c.i >> 63))
!                         vtop->a.c.ld = vtop->a.c.i;
                      else
!                         vtop->a.c.ld = -(long double)-vtop->a.c.i;
                  } else if(!sf) {
!                     if ((sbt & VT_UNSIGNED) || !(vtop->a.c.i >> 31))
!                         vtop->a.c.ld = (uint32_t)vtop->a.c.i;
                      else
!                         vtop->a.c.ld = -(long double)-(uint32_t)vtop->a.c.i;
                  }
  
                  if (dbt == VT_FLOAT)
!                     vtop->a.c.f = (float)vtop->a.c.ld;
                  else if (dbt == VT_DOUBLE)
!                     vtop->a.c.d = (double)vtop->a.c.ld;
              } else if (sf && dbt == VT_BOOL) {
!                 vtop->a.c.i = (vtop->a.c.ld != 0);
              } else {
                  if(sf)
!                     vtop->a.c.i = vtop->a.c.ld;
                  else if (sbt_bt == VT_LLONG || (PTR_SIZE == 8 && sbt == VT_PTR))
                      ;
                  else if (sbt & VT_UNSIGNED)
!                     vtop->a.c.i = (uint32_t)vtop->a.c.i;
                  else
!                     vtop->a.c.i = ((uint32_t)vtop->a.c.i | -(vtop->a.c.i & 0x80000000));
  
                  if (dbt_bt == VT_LLONG || (PTR_SIZE == 8 && dbt == VT_PTR))
                      ;
                  else if (dbt == VT_BOOL)
!                     vtop->a.c.i = (vtop->a.c.i != 0);
                  else {
                      uint32_t m = dbt_bt == VT_BYTE ? 0xff :
                                   dbt_bt == VT_SHORT ? 0xffff :
                                    0xffffffff;
!                     vtop->a.c.i &= m;
                      if (!(dbt & VT_UNSIGNED))
!                         vtop->a.c.i |= -(vtop->a.c.i & ((m >> 1) + 1));
                  }
              }
              goto done;
***************
*** 3121,3127 ****
                  == (VT_CONST | VT_SYM)) {
              /* addresses are considered non-zero (see tcctest.c:sinit23) */
              vtop->r = VT_CONST;
!             vtop->c.i = 1;
              goto done;
          }
  
--- 3123,3129 ----
                  == (VT_CONST | VT_SYM)) {
              /* addresses are considered non-zero (see tcctest.c:sinit23) */
              vtop->r = VT_CONST;
!             vtop->a.c.i = 1;
              goto done;
          }
  
***************
*** 3158,3164 ****
          if (ds == 0 || ss == 0)
              goto error;
  
!         if (IS_ENUM(type->t) && type->ref->c < 0)
              tcc_error("cast to incomplete type");
  
          /* same size and no sign conversion needed */
--- 3160,3166 ----
          if (ds == 0 || ss == 0)
              goto error;
  
!         if (IS_ENUM(type->t) && type->ref->b.a.c < 0)
              tcc_error("cast to incomplete type");
  
          /* same size and no sign conversion needed */
***************
*** 3271,3277 ****
          /* struct/union */
          s = type->ref;
          *a = s->r;
!         return s->c;
      } else if (bt == VT_PTR) {
          if (type->t & VT_ARRAY) {
              int ts;
--- 3273,3279 ----
          /* struct/union */
          s = type->ref;
          *a = s->r;
!         return s->b.a.c;
      } else if (bt == VT_PTR) {
          if (type->t & VT_ARRAY) {
              int ts;
***************
*** 3279,3293 ****
              s = type->ref;
              ts = type_size(&s->type, a);
  
!             if (ts < 0 && s->c < 0)
                  ts = -ts;
  
!             return ts * s->c;
          } else {
              *a = PTR_SIZE;
              return PTR_SIZE;
          }
!     } else if (IS_ENUM(type->t) && type->ref->c < 0) {
          *a = 0;
          return -1; /* incomplete enum */
      } else if (bt == VT_LDOUBLE) {
--- 3281,3295 ----
              s = type->ref;
              ts = type_size(&s->type, a);
  
!             if (ts < 0 && s->b.a.c < 0)
                  ts = -ts;
  
!             return ts * s->b.a.c;
          } else {
              *a = PTR_SIZE;
              return PTR_SIZE;
          }
!     } else if (IS_ENUM(type->t) && type->ref->b.a.c < 0) {
          *a = 0;
          return -1; /* incomplete enum */
      } else if (bt == VT_LDOUBLE) {
***************
*** 3332,3338 ****
  {
      if (type->t & VT_VLA) {
          type_size(&type->ref->type, a);
!         vset(&int_type, VT_LOCAL|VT_LVAL, type->ref->c);
      } else {
          int size = type_size(type, a);
          if (size < 0)
--- 3334,3340 ----
  {
      if (type->t & VT_VLA) {
          type_size(&type->ref->type, a);
!         vset(&int_type, VT_LOCAL|VT_LVAL, type->ref->b.a.c);
      } else {
          int size = type_size(type, a);
          if (size < 0)
***************
*** 3608,3614 ****
  
              if (delayed_cast) {
                  vtop->r |= BFVAL(VT_MUSTCAST, (sbt == VT_LLONG) + 1);
!                 //tcc_warning("deley cast %x -> %x", sbt, dbt);
                  vtop->type.t = ft & VT_TYPE;
              }
  
--- 3610,3616 ----
  
              if (delayed_cast) {
                  vtop->r |= BFVAL(VT_MUSTCAST, (sbt == VT_LLONG) + 1);
!                 /* //tcc_warning("deley cast %x -> %x", sbt, dbt); */
                  vtop->type.t = ft & VT_TYPE;
              }
  
***************
*** 3618,3624 ****
                  r = get_reg(RC_INT);
                  sv.type.t = VT_PTRDIFF_T;
                  sv.r = VT_LOCAL | VT_LVAL;
!                 sv.c.i = vtop[-1].c.i;
                  load(r, &sv);
                  vtop[-1].r = r | VT_LVAL;
              }
--- 3620,3626 ----
                  r = get_reg(RC_INT);
                  sv.type.t = VT_PTRDIFF_T;
                  sv.r = VT_LOCAL | VT_LVAL;
!                 sv.a.c.i = vtop[-1].a.c.i;
                  load(r, &sv);
                  vtop[-1].r = r | VT_LVAL;
              }
***************
*** 3904,3916 ****
  {
      Sym *s = type->ref;
      v |= SYM_FIELD;
!     while ((s = s->next) != NULL) {
  	if ((s->v & SYM_FIELD) &&
  	    (s->type.t & VT_BTYPE) == VT_STRUCT &&
  	    (s->v & ~SYM_FIELD) >= SYM_FIRST_ANOM) {
  	    Sym *ret = find_field (&s->type, v, cumofs);
  	    if (ret) {
!                 *cumofs += s->c;
  	        return ret;
              }
  	}
--- 3906,3918 ----
  {
      Sym *s = type->ref;
      v |= SYM_FIELD;
!     while ((s = s->e.next) != NULL) {
  	if ((s->v & SYM_FIELD) &&
  	    (s->type.t & VT_BTYPE) == VT_STRUCT &&
  	    (s->v & ~SYM_FIELD) >= SYM_FIRST_ANOM) {
  	    Sym *ret = find_field (&s->type, v, cumofs);
  	    if (ret) {
!                 *cumofs += s->b.a.c;
  	        return ret;
              }
  	}
***************
*** 3924,3930 ****
  {
      Sym *s = type->ref;
  
!     while ((s = s->next) != NULL) {
          int v = s->v & ~SYM_FIELD;
          if (v < SYM_FIRST_ANOM) {
              TokenSym *ts = table_ident[v - TOK_IDENT];
--- 3926,3932 ----
  {
      Sym *s = type->ref;
  
!     while ((s = s->e.next) != NULL) {
          int v = s->v & ~SYM_FIELD;
          if (v < SYM_FIRST_ANOM) {
              TokenSym *ts = table_ident[v - TOK_IDENT];
***************
*** 3951,3959 ****
      prevbt = VT_STRUCT; /* make it never match */
      prev_bit_size = 0;
  
! //#define BF_DEBUG
  
!     for (f = type->ref->next; f; f = f->next) {
          if (f->type.t & VT_BITFIELD)
              bit_size = BIT_SIZE(f->type.t);
          else
--- 3953,3961 ----
      prevbt = VT_STRUCT; /* make it never match */
      prev_bit_size = 0;
  
! /* //#define BF_DEBUG */
  
!     for (f = type->ref->e.next; f; f = f->e.next) {
          if (f->type.t & VT_BITFIELD)
              bit_size = BIT_SIZE(f->type.t);
          else
***************
*** 4037,4043 ****
  		   of the containing struct using the base types alignment,
  		   except for packed fields (which here have correct align).  */
  		if (f->v & SYM_FIRST_ANOM
!                     // && bit_size // ??? gcc on ARM/rpi does that
                      )
  		    align = 1;
  
--- 4039,4045 ----
  		   of the containing struct using the base types alignment,
  		   except for packed fields (which here have correct align).  */
  		if (f->v & SYM_FIRST_ANOM
!                     /* // && bit_size // ??? gcc on ARM/rpi does that */
                      )
  		    align = 1;
  
***************
*** 4085,4091 ****
  	printf("\n");
  #endif
  
!         f->c = offset;
  	f->r = 0;
      }
  
--- 4087,4093 ----
  	printf("\n");
  #endif
  
!         f->b.a.c = offset;
  	f->r = 0;
      }
  
***************
*** 4105,4132 ****
              a = bt;
      }
      c = (c + a - 1) & -a;
!     type->ref->c = c;
  
  #ifdef BF_DEBUG
      printf("struct size %-2d align %-2d\n\n", c, a), fflush(stdout);
  #endif
  
      /* check whether we can access bitfields by their type */
!     for (f = type->ref->next; f; f = f->next) {
          int s, px, cx, c0;
          CType t;
  
          if (0 == (f->type.t & VT_BITFIELD))
              continue;
          f->type.ref = f;
!         f->auxtype = -1;
          bit_size = BIT_SIZE(f->type.t);
          if (bit_size == 0)
              continue;
          bit_pos = BIT_POS(f->type.t);
          size = type_size(&f->type, &align);
  
!         if (bit_pos + bit_size <= size * 8 && f->c + size <= c
  #ifdef TCC_TARGET_ARM
              && !(f->c & (align - 1))
  #endif
--- 4107,4134 ----
              a = bt;
      }
      c = (c + a - 1) & -a;
!     type->ref->b.a.c = c;
  
  #ifdef BF_DEBUG
      printf("struct size %-2d align %-2d\n\n", c, a), fflush(stdout);
  #endif
  
      /* check whether we can access bitfields by their type */
!     for (f = type->ref->e.next; f; f = f->e.next) {
          int s, px, cx, c0;
          CType t;
  
          if (0 == (f->type.t & VT_BITFIELD))
              continue;
          f->type.ref = f;
!         f->b.a.a.auxtype = -1;
          bit_size = BIT_SIZE(f->type.t);
          if (bit_size == 0)
              continue;
          bit_pos = BIT_POS(f->type.t);
          size = type_size(&f->type, &align);
  
!         if (bit_pos + bit_size <= size * 8 && f->b.a.c + size <= c
  #ifdef TCC_TARGET_ARM
              && !(f->c & (align - 1))
  #endif
***************
*** 4137,4143 ****
          c0 = -1, s = align = 1;
          t.t = VT_BYTE;
          for (;;) {
!             px = f->c * 8 + bit_pos;
              cx = (px >> 3) & -align;
              px = px - (cx << 3);
              if (c0 == cx)
--- 4139,4145 ----
          c0 = -1, s = align = 1;
          t.t = VT_BYTE;
          for (;;) {
!             px = f->b.a.c * 8 + bit_pos;
              cx = (px >> 3) & -align;
              px = px - (cx << 3);
              if (c0 == cx)
***************
*** 4162,4173 ****
  #endif
              ) {
              /* update offset and bit position */
!             f->c = cx;
              bit_pos = px;
  	    f->type.t = (f->type.t & ~(0x3f << VT_STRUCT_SHIFT))
  		        | (bit_pos << VT_STRUCT_SHIFT);
              if (s != size)
!                 f->auxtype = t.t;
  #ifdef BF_DEBUG
              printf("FIX field %s offset %-2d size %-2d align %-2d "
                  "pos %-2d bits %-2d\n",
--- 4164,4175 ----
  #endif
              ) {
              /* update offset and bit position */
!             f->b.a.c = cx;
              bit_pos = px;
  	    f->type.t = (f->type.t & ~(0x3f << VT_STRUCT_SHIFT))
  		        | (bit_pos << VT_STRUCT_SHIFT);
              if (s != size)
!                 f->b.a.a.auxtype = t.t;
  #ifdef BF_DEBUG
              printf("FIX field %s offset %-2d size %-2d align %-2d "
                  "pos %-2d bits %-2d\n",
***************
*** 4176,4182 ****
  #endif
          } else {
              /* fall back to load/store single-byte wise */
!             f->auxtype = VT_STRUCT;
  #ifdef BF_DEBUG
              printf("FIX field %s : load byte-wise\n",
                   get_tok_str(f->v & ~SYM_FIELD, NULL));
--- 4178,4184 ----
  #endif
          } else {
              /* fall back to load/store single-byte wise */
!             f->b.a.a.auxtype = VT_STRUCT;
  #ifdef BF_DEBUG
              printf("FIX field %s : load byte-wise\n",
                   get_tok_str(f->v & ~SYM_FIELD, NULL));
***************
*** 4204,4210 ****
          if (v < TOK_IDENT)
              expect("struct/union/enum name");
          s = struct_find(v);
!         if (s && (s->sym_scope == local_scope || tok != '{')) {
              if (u == s->type.t)
                  goto do_decl;
              if (u == VT_ENUM && IS_ENUM(s->type.t))
--- 4206,4212 ----
          if (v < TOK_IDENT)
              expect("struct/union/enum name");
          s = struct_find(v);
!         if (s && (s->b.a.a.sym_scope == local_scope || tok != '{')) {
              if (u == s->type.t)
                  goto do_decl;
              if (u == VT_ENUM && IS_ENUM(s->type.t))
***************
*** 4226,4237 ****
  
      if (tok == '{') {
          next();
!         if (s->c != -1)
              tcc_error("struct/union/enum already defined");
!         s->c = -2;
          /* cannot be empty */
          /* non empty enums are not allowed */
!         ps = &s->next;
          if (u == VT_ENUM) {
              long long ll = 0, pl = 0, nl = 0;
  	    CType t;
--- 4228,4239 ----
  
      if (tok == '{') {
          next();
!         if (s->b.a.c != -1)
              tcc_error("struct/union/enum already defined");
!         s->b.a.c = -2;
          /* cannot be empty */
          /* non empty enums are not allowed */
!         ps = &s->e.next;
          if (u == VT_ENUM) {
              long long ll = 0, pl = 0, nl = 0;
  	    CType t;
***************
*** 4252,4259 ****
  		    ll = expr_const64();
                  }
                  ss = sym_push(v, &t, VT_CONST, 0);
!                 ss->enum_val = ll;
!                 *ps = ss, ps = &ss->next;
                  if (ll < nl)
                      nl = ll;
                  if (ll > pl)
--- 4254,4261 ----
  		    ll = expr_const64();
                  }
                  ss = sym_push(v, &t, VT_CONST, 0);
!                 ss->b.enum_val = ll;
!                 *ps = ss, ps = &ss->e.next;
                  if (ll < nl)
                      nl = ll;
                  if (ll > pl)
***************
*** 4276,4285 ****
              } else if (pl != (int)pl || nl != (int)nl)
                  t.t = (LONG_SIZE==8 ? VT_LLONG|VT_LONG : VT_LLONG);
              s->type.t = type->t = t.t | VT_ENUM;
!             s->c = 0;
              /* set type for enum members */
!             for (ss = s->next; ss; ss = ss->next) {
!                 ll = ss->enum_val;
                  if (ll == (int)ll) /* default is int if it fits */
                      continue;
                  if (t.t & VT_UNSIGNED) {
--- 4278,4287 ----
              } else if (pl != (int)pl || nl != (int)nl)
                  t.t = (LONG_SIZE==8 ? VT_LLONG|VT_LONG : VT_LLONG);
              s->type.t = type->t = t.t | VT_ENUM;
!             s->b.a.c = 0;
              /* set type for enum members */
!             for (ss = s->e.next; ss; ss = ss->e.next) {
!                 ll = ss->b.enum_val;
                  if (ll == (int)ll) /* default is int if it fits */
                      continue;
                  if (t.t & VT_UNSIGNED) {
***************
*** 4385,4391 ****
                          ss = sym_push(v | SYM_FIELD, &type1, 0, 0);
                          ss->a = ad1.a;
                          *ps = ss;
!                         ps = &ss->next;
                      }
                      if (tok == ';' || tok == TOK_EOF)
                          break;
--- 4387,4393 ----
                          ss = sym_push(v | SYM_FIELD, &type1, 0, 0);
                          ss->a = ad1.a;
                          *ps = ss;
!                         ps = &ss->e.next;
                      }
                      if (tok == ';' || tok == TOK_EOF)
                          break;
***************
*** 4410,4416 ****
  static void sym_to_attr(AttributeDef *ad, Sym *s)
  {
      merge_symattr(&ad->a, &s->a);
!     merge_funcattr(&ad->f, &s->f);
  }
  
  /* Add type qualifiers to a type. If the type is an array then the qualifiers
--- 4412,4418 ----
  static void sym_to_attr(AttributeDef *ad, Sym *s)
  {
      merge_symattr(&ad->a, &s->a);
!     merge_funcattr(&ad->f, &s->b.a.a.f);
  }
  
  /* Add type qualifiers to a type. If the type is an array then the qualifiers
***************
*** 4418,4424 ****
  static void parse_btype_qualify(CType *type, int qualifiers)
  {
      while (type->t & VT_ARRAY) {
!         type->ref = sym_push(SYM_FIELD, &type->ref->type, 0, type->ref->c);
          type = &type->ref->type;
      }
      type->t |= qualifiers;
--- 4420,4426 ----
  static void parse_btype_qualify(CType *type, int qualifiers)
  {
      while (type->t & VT_ARRAY) {
!         type->ref = sym_push(SYM_FIELD, &type->ref->type, 0, type->ref->b.a.c);
          type = &type->ref->type;
      }
      type->t |= qualifiers;
***************
*** 4777,4783 ****
                  arg_size += (type_size(&pt, &align) + PTR_SIZE - 1) / PTR_SIZE;
                  s = sym_push(n, &pt, 0, 0);
                  *plast = s;
!                 plast = &s->next;
                  if (tok == ')')
                      break;
                  skip(',');
--- 4779,4785 ----
                  arg_size += (type_size(&pt, &align) + PTR_SIZE - 1) / PTR_SIZE;
                  s = sym_push(n, &pt, 0, 0);
                  *plast = s;
!                 plast = &s->e.next;
                  if (tok == ')')
                      break;
                  skip(',');
***************
*** 4796,4802 ****
          /* remove parameter symbols from token table, keep on stack */
          if (first) {
              sym_pop(local_stack ? &local_stack : &global_stack, first->prev, 1);
!             for (s = first; s; s = s->next)
                  s->v |= SYM_FIELD;
          }
          --local_scope;
--- 4798,4804 ----
          /* remove parameter symbols from token table, keep on stack */
          if (first) {
              sym_pop(local_stack ? &local_stack : &global_stack, first->prev, 1);
!             for (s = first; s; s = s->e.next)
                  s->v |= SYM_FIELD;
          }
          --local_scope;
***************
*** 4816,4823 ****
          ad->f.func_type = l;
          s = sym_push(SYM_FIELD, type, 0, 0);
          s->a = ad->a;
!         s->f = ad->f;
!         s->next = first;
          type->t = VT_FUNC;
          type->ref = s;
      } else if (tok == '[') {
--- 4818,4825 ----
          ad->f.func_type = l;
          s = sym_push(SYM_FIELD, type, 0, 0);
          s->a = ad->a;
!         s->b.a.a.f = ad->f;
!         s->e.next = first;
          type->t = VT_FUNC;
          type->ref = s;
      } else if (tok == '[') {
***************
*** 4885,4891 ****
  	    }
  check:
              if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {
!                 n = vtop->c.i;
                  if (n < 0)
                      tcc_error("invalid array size");
              } else {
--- 4887,4893 ----
  	    }
  check:
              if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {
!                 n = vtop->a.c.i;
                  if (n < 0)
                      tcc_error("invalid array size");
              } else {
***************
*** 4935,4941 ****
          type->ref = s;
  	if (vla_array_str) {
  	    if (t1 & VT_VLA)
! 	        s->vla_array_str = vla_array_str;
  	    else
  	        tok_str_free_str(vla_array_str);
  	}
--- 4937,4943 ----
          type->ref = s;
  	if (vla_array_str) {
  	    if (t1 & VT_VLA)
! 	        s->e.vla_array_str = vla_array_str;
  	    else
  	        tok_str_free_str(vla_array_str);
  	}
***************
*** 5053,5059 ****
      int func_type;
      CType type;
  
!     func_type = func->f.func_type;
      if (func_type == FUNC_OLD ||
          (func_type == FUNC_ELLIPSIS && arg == NULL)) {
          /* default casting : only need to convert float to double */
--- 5055,5061 ----
      int func_type;
      CType type;
  
!     func_type = func->b.a.a.f.func_type;
      if (func_type == FUNC_OLD ||
          (func_type == FUNC_ELLIPSIS && arg == NULL)) {
          /* default casting : only need to convert float to double */
***************
*** 5343,5349 ****
                  type.t |= VT_CONSTANT;
              mk_pointer(&type);
              type.t |= VT_ARRAY;
!             type.ref->c = len;
              sec = rodata_section;
              vpush_ref(&type, sec, sec->data_offset, len);
              if (!NODATA_WANTED)
--- 5345,5351 ----
                  type.t |= VT_CONSTANT;
              mk_pointer(&type);
              type.t |= VT_ARRAY;
!             type.ref->b.a.c = len;
              sec = rodata_section;
              vpush_ref(&type, sec, sec->data_offset, len);
              if (!NODATA_WANTED)
***************
*** 5439,5446 ****
          if ((vtop->type.t & VT_BTYPE) != VT_FUNC &&
              !(vtop->type.t & VT_ARRAY))
              test_lvalue();
!         if (vtop->sym)
!           vtop->sym->a.addrtaken = 1;
          mk_pointer(&vtop->type);
          gaddrof();
          break;
--- 5441,5448 ----
          if ((vtop->type.t & VT_BTYPE) != VT_FUNC &&
              !(vtop->type.t & VT_ARRAY))
              test_lvalue();
!         if (vtop->b.sym)
!           vtop->b.sym->a.addrtaken = 1;
          mk_pointer(&vtop->type);
          gaddrof();
          break;
***************
*** 5483,5489 ****
              type_size(&type, &align);
              s = NULL;
              if (vtop[1].r & VT_SYM)
!                 s = vtop[1].sym; /* hack: accessing previous vtop */
              if (s && s->a.aligned)
                  align = 1 << (s->a.aligned - 1);
              vpushs(align);
--- 5485,5491 ----
              type_size(&type, &align);
              s = NULL;
              if (vtop[1].r & VT_SYM)
!                 s = vtop[1].b.sym; /* hack: accessing previous vtop */
              if (s && s->a.aligned)
                  align = 1 << (s->a.aligned - 1);
              vpushs(align);
***************
*** 5533,5539 ****
      case TOK_builtin_constant_p:
  	parse_builtin_params(1, "e");
  	n = (vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST &&
!             !((vtop->r & VT_SYM) && vtop->sym->a.addrtaken);
  	vtop--;
  	vpushi(n);
          break;
--- 5535,5541 ----
      case TOK_builtin_constant_p:
  	parse_builtin_params(1, "e");
  	n = (vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST &&
!             !((vtop->r & VT_SYM) && vtop->b.sym->a.addrtaken);
  	vtop--;
  	vpushi(n);
          break;
***************
*** 5565,5571 ****
                  indir();                    /* -> parent frame */
              }
              if (tok1 == TOK_builtin_return_address) {
!                 // assume return address is just above frame pointer on stack
  #ifdef TCC_TARGET_ARM
                  vpushi(2*PTR_SIZE);
                  gen_op('+');
--- 5567,5573 ----
                  indir();                    /* -> parent frame */
              }
              if (tok1 == TOK_builtin_return_address) {
!                 /* // assume return address is just above frame pointer on stack */
  #ifdef TCC_TARGET_ARM
                  vpushi(2*PTR_SIZE);
                  gen_op('+');
***************
*** 5620,5626 ****
  #ifdef TCC_TARGET_ARM64
      case TOK_builtin_va_start: {
  	parse_builtin_params(0, "ee");
!         //xx check types
          gen_va_start();
          vpushi(0);
          vtop->type.t = VT_VOID;
--- 5622,5628 ----
  #ifdef TCC_TARGET_ARM64
      case TOK_builtin_va_start: {
  	parse_builtin_params(0, "ee");
!         /* //xx check types */
          gen_va_start();
          vpushi(0);
          vtop->type.t = VT_VOID;
***************
*** 5630,5636 ****
  	parse_builtin_params(0, "et");
  	type = vtop->type;
  	vpop();
!         //xx check types
          gen_va_arg(&type);
          vtop->type = type;
          break;
--- 5632,5638 ----
  	parse_builtin_params(0, "et");
  	type = vtop->type;
  	vpop();
!         /* //xx check types */
          gen_va_arg(&type);
          vtop->type = type;
          break;
***************
*** 5766,5772 ****
          next();
  	break;
      }
!     // special qnan , snan and infinity values
      case TOK___NAN__:
          n = 0x7fc00000;
  special_math_val:
--- 5768,5774 ----
          next();
  	break;
      }
!     /* // special qnan , snan and infinity values */
      case TOK___NAN__:
          n = 0x7fc00000;
  special_math_val:
***************
*** 5805,5820 ****
          if ((r & VT_VALMASK) < VT_CONST)
              r = (r & ~VT_VALMASK) | VT_LOCAL;
  
!         vset(&s->type, r, s->c);
          /* Point to s as backpointer (even without r&VT_SYM).
! 	   Will be used by at least the x86 inline asm parser for
  	   regvars.  */
! 	vtop->sym = s;
  
          if (r & VT_SYM) {
!             vtop->c.i = 0;
          } else if (r == VT_CONST && IS_ENUM_VAL(s->type.t)) {
!             vtop->c.i = s->enum_val;
          }
          break;
      }
--- 5807,5822 ----
          if ((r & VT_VALMASK) < VT_CONST)
              r = (r & ~VT_VALMASK) | VT_LOCAL;
  
!         vset(&s->type, r, s->b.a.c);
          /* Point to s as backpointer (even without r&VT_SYM).
! 	   Will be used by at least the x86 asm parser for
  	   regvars.  */
! 	vtop->b.sym = s;
  
          if (r & VT_SYM) {
!             vtop->a.c.i = 0;
          } else if (r == VT_CONST && IS_ENUM_VAL(s->type.t)) {
!             vtop->a.c.i = s->b.enum_val;
          }
          break;
      }
***************
*** 5845,5851 ****
                  tcc_error("field not found: %s",  get_tok_str(tok & ~SYM_FIELD, &tokc));
              /* add field offset to pointer */
              vtop->type = char_pointer_type; /* change type to 'char *' */
!             vpushi(cumofs + s->c);
              gen_op('+');
              /* change type to field type, and set to lvalue */
              vtop->type = s->type;
--- 5847,5853 ----
                  tcc_error("field not found: %s",  get_tok_str(tok & ~SYM_FIELD, &tokc));
              /* add field offset to pointer */
              vtop->type = char_pointer_type; /* change type to 'char *' */
!             vpushi(cumofs + s->b.a.c);
              gen_op('+');
              /* change type to field type, and set to lvalue */
              vtop->type = s->type;
***************
*** 5888,5899 ****
              /* get return type */
              s = vtop->type.ref;
              next();
!             sa = s->next; /* first parameter */
              nb_args = regsize = 0;
              ret.r2 = VT_CONST;
              /* compute first implicit argument if a structure is returned */
              if ((s->type.t & VT_BTYPE) == VT_STRUCT) {
!                 variadic = (s->f.func_type == FUNC_ELLIPSIS);
                  ret_nregs = gfunc_sret(&s->type, variadic, &ret.type,
                                         &ret_align, &regsize);
                  if (ret_nregs <= 0) {
--- 5890,5901 ----
              /* get return type */
              s = vtop->type.ref;
              next();
!             sa = s->e.next; /* first parameter */
              nb_args = regsize = 0;
              ret.r2 = VT_CONST;
              /* compute first implicit argument if a structure is returned */
              if ((s->type.t & VT_BTYPE) == VT_STRUCT) {
!                 variadic = (s->b.a.a.f.func_type == FUNC_ELLIPSIS);
                  ret_nregs = gfunc_sret(&s->type, variadic, &ret.type,
                                         &ret_align, &regsize);
                  if (ret_nregs <= 0) {
***************
*** 5918,5924 ****
                      if (tcc_state->do_bounds_check)
                          --loc;
  #endif
!                     ret.c = vtop->c;
                      if (ret_nregs < 0)
                        vtop--;
                      else
--- 5920,5926 ----
                      if (tcc_state->do_bounds_check)
                          --loc;
  #endif
!                     ret.a.c = vtop->a.c;
                      if (ret_nregs < 0)
                        vtop--;
                      else
***************
*** 5931,5937 ****
  
              if (ret_nregs > 0) {
                  /* return in register */
!                 ret.c.i = 0;
                  PUT_R_RET(&ret, ret.type.t);
              }
              if (tok != ')') {
--- 5933,5939 ----
  
              if (ret_nregs > 0) {
                  /* return in register */
!                 ret.a.c.i = 0;
                  PUT_R_RET(&ret, ret.type.t);
              }
              if (tok != ')') {
***************
*** 5940,5946 ****
                      gfunc_param_typed(s, sa);
                      nb_args++;
                      if (sa)
!                         sa = sa->next;
                      if (tok == ')')
                          break;
                      skip(',');
--- 5942,5948 ----
                      gfunc_param_typed(s, sa);
                      nb_args++;
                      if (sa)
!                         sa = sa->e.next;
                      if (tok == ')')
                          break;
                      skip(',');
***************
*** 5952,5965 ****
              gfunc_call(nb_args);
  
              if (ret_nregs < 0) {
!                 vsetc(&ret.type, ret.r, &ret.c);
  #ifdef TCC_TARGET_RISCV64
                  arch_transfer_ret_regs(1);
  #endif
              } else {
                  /* return value */
                  for (r = ret.r + ret_nregs + !ret_nregs; r-- > ret.r;) {
!                     vsetc(&ret.type, r, &ret.c);
                      vtop->r2 = ret.r2; /* Loop only happens when r2 is VT_CONST */
                  }
  
--- 5954,5967 ----
              gfunc_call(nb_args);
  
              if (ret_nregs < 0) {
!                 vsetc(&ret.type, ret.r, &ret.a.c);
  #ifdef TCC_TARGET_RISCV64
                  arch_transfer_ret_regs(1);
  #endif
              } else {
                  /* return value */
                  for (r = ret.r + ret_nregs + !ret_nregs; r-- > ret.r;) {
!                     vsetc(&ret.type, r, &ret.a.c);
                      vtop->r2 = ret.r2; /* Loop only happens when r2 is VT_CONST */
                  }
  
***************
*** 6001,6007 ****
  #endif
                  }
              }
!             if (s->f.func_noreturn) {
                  if (debug_modes)
  	            tcc_tcov_block_end(tcc_state, -1);
                  CODE_OFF();
--- 6003,6009 ----
  #endif
                  }
              }
!             if (s->b.a.a.f.func_noreturn) {
                  if (debug_modes)
  	            tcc_tcov_block_end(tcc_state, -1);
                  CODE_OFF();
***************
*** 6181,6190 ****
  {
      int c = -1;
      if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST &&
! 	(!(vtop->r & VT_SYM) || !vtop->sym->a.weak)) {
  	vdup();
          gen_cast_s(VT_BOOL);
! 	c = vtop->c.i;
  	vpop();
      }
      return c;
--- 6183,6192 ----
  {
      int c = -1;
      if ((vtop->r & (VT_VALMASK | VT_LVAL)) == VT_CONST &&
! 	(!(vtop->r & VT_SYM) || !vtop->b.sym->a.weak)) {
  	vdup();
          gen_cast_s(VT_BOOL);
! 	c = vtop->a.c.i;
  	vpop();
      }
      return c;
***************
*** 6222,6228 ****
  {
      if ((sv->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST
          && (sv->type.t & VT_BTYPE) == VT_INT)
!         return (unsigned)sv->c.i < 2;
      if (sv->r == VT_CMP)
          return 1;
      return 0;
--- 6224,6230 ----
  {
      if ((sv->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST
          && (sv->type.t & VT_BTYPE) == VT_INT)
!         return (unsigned)sv->a.c.i < 2;
      if (sv->r == VT_CMP)
          return 1;
      return 0;
***************
*** 6293,6299 ****
              gvtst_set(0, t1);
              gvtst_set(1, t2);
              nocode_wanted = ncw_prev;
!             //  tcc_warning("two conditions expr_cond");
              return;
          }
  
--- 6295,6301 ----
              gvtst_set(0, t1);
              gvtst_set(1, t2);
              nocode_wanted = ncw_prev;
!             /* //  tcc_warning("two conditions expr_cond"); */
              return;
          }
  
***************
*** 6403,6409 ****
      expr_const1();
      if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)
          expect("constant expression");
!     c = vtop->c.i;
      vpop();
      return c;
  }
--- 6405,6411 ----
      expr_const1();
      if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)
          expect("constant expression");
!     c = vtop->a.c.i;
      vpop();
      return c;
  }
***************
*** 6450,6456 ****
              int size, addr, align, rc;
              size = type_size(func_type,&align);
              if ((vtop->r != (VT_LOCAL | VT_LVAL) ||
!                  (vtop->c.i & (ret_align-1)))
                  && (align & (ret_align-1))) {
                  loc = (loc - size) & -ret_align;
                  addr = loc;
--- 6452,6458 ----
              int size, addr, align, rc;
              size = type_size(func_type,&align);
              if ((vtop->r != (VT_LOCAL | VT_LVAL) ||
!                  (vtop->a.c.i & (ret_align-1)))
                  && (align & (ret_align-1))) {
                  loc = (loc - size) & -ret_align;
                  addr = loc;
***************
*** 6476,6482 ****
                         registers, their classes are consecutive values of the
                         suite s(n) = 2^n */
                      rc <<= 1;
!                     vtop->c.i += regsize;
                  }
              }
          }
--- 6478,6484 ----
                         registers, their classes are consecutive values of the
                         suite s(n) = 2^n */
                      rc <<= 1;
!                     vtop->a.c.i += regsize;
                  }
              }
          }
***************
*** 6587,6599 ****
  {
      Sym *cls = cur_scope->cl.s;
  
!     for (; cls != stop; cls = cls->ncl) {
! 	Sym *fs = cls->next;
  	Sym *vs = cls->prev_tok;
  
  	vpushsym(&fs->type, fs);
! 	vset(&vs->type, vs->r, vs->c);
! 	vtop->sym = vs;
          mk_pointer(&vtop->type);
  	gaddrof();
  	gfunc_call(1);
--- 6589,6601 ----
  {
      Sym *cls = cur_scope->cl.s;
  
!     for (; cls != stop; cls = cls->b.ncl) {
! 	Sym *fs = cls->e.next;
  	Sym *vs = cls->prev_tok;
  
  	vpushsym(&fs->type, fs);
! 	vset(&vs->type, vs->r, vs->b.a.c);
! 	vtop->b.sym = vs;
          mk_pointer(&vtop->type);
  	gaddrof();
  	gfunc_call(1);
***************
*** 6610,6620 ****
  
      /* search NCA of both cleanup chains given parents and initial depth */
      ocd = cleanupstate ? cleanupstate->v & ~SYM_FIELD : 0;
!     for (ccd = cur_scope->cl.n, oc = cleanupstate; ocd > ccd; --ocd, oc = oc->ncl)
        ;
!     for (cc = cur_scope->cl.s; ccd > ocd; --ccd, cc = cc->ncl)
        ;
!     for (; cc != oc; cc = cc->ncl, oc = oc->ncl, --ccd)
        ;
  
      try_call_scope_cleanup(cc);
--- 6612,6622 ----
  
      /* search NCA of both cleanup chains given parents and initial depth */
      ocd = cleanupstate ? cleanupstate->v & ~SYM_FIELD : 0;
!     for (ccd = cur_scope->cl.n, oc = cleanupstate; ocd > ccd; --ocd, oc = oc->b.ncl)
        ;
!     for (cc = cur_scope->cl.s; ccd > ocd; --ccd, cc = cc->b.ncl)
        ;
!     for (; cc != oc; cc = cc->b.ncl, oc = oc->b.ncl, --ccd)
        ;
  
      try_call_scope_cleanup(cc);
***************
*** 6625,6641 ****
  {
      int jmp = 0;
      Sym *g, **pg;
!     for (pg = &pending_gotos; (g = *pg) && g->c > o->cl.n;) {
          if (g->prev_tok->r & LABEL_FORWARD) {
!             Sym *pcl = g->next;
              if (!jmp)
                  jmp = gjmp(0);
!             gsym(pcl->jnext);
              try_call_scope_cleanup(o->cl.s);
!             pcl->jnext = gjmp(0);
              if (!o->cl.n)
                  goto remove_pending;
!             g->c = o->cl.n;
              pg = &g->prev;
          } else {
      remove_pending:
--- 6627,6643 ----
  {
      int jmp = 0;
      Sym *g, **pg;
!     for (pg = &pending_gotos; (g = *pg) && g->b.a.c > o->cl.n;) {
          if (g->prev_tok->r & LABEL_FORWARD) {
!             Sym *pcl = g->e.next;
              if (!jmp)
                  jmp = gjmp(0);
!             gsym(pcl->b.a.a.jnext);
              try_call_scope_cleanup(o->cl.s);
!             pcl->b.a.a.jnext = gjmp(0);
              if (!o->cl.n)
                  goto remove_pending;
!             g->b.a.c = o->cl.n;
              pg = &g->prev;
          } else {
      remove_pending:
***************
*** 7021,7033 ****
  		if (cur_scope->cl.s && !nocode_wanted) {
                      sym_push2(&pending_gotos, SYM_FIELD, 0, cur_scope->cl.n);
                      pending_gotos->prev_tok = s;
!                     s = sym_push2(&s->next, SYM_FIELD, 0, 0);
!                     pending_gotos->next = s;
                  }
! 		s->jnext = gjmp(s->jnext);
  	    } else {
! 		try_call_cleanup_goto(s->cleanupstate);
! 		gjmp_addr(s->jnext);
  	    }
  	    next();
  
--- 7023,7035 ----
  		if (cur_scope->cl.s && !nocode_wanted) {
                      sym_push2(&pending_gotos, SYM_FIELD, 0, cur_scope->cl.n);
                      pending_gotos->prev_tok = s;
!                     s = sym_push2(&s->e.next, SYM_FIELD, 0, 0);
!                     pending_gotos->e.next = s;
                  }
! 		s->b.a.a.jnext = gjmp(s->b.a.a.jnext);
  	    } else {
! 		try_call_cleanup_goto(s->e.cleanupstate);
! 		gjmp_addr(s->b.a.a.jnext);
  	    }
  	    next();
  
***************
*** 7048,7065 ****
                  if (s->r == LABEL_DEFINED)
                      tcc_error("duplicate label '%s'", get_tok_str(s->v, NULL));
                  s->r = LABEL_DEFINED;
! 		if (s->next) {
  		    Sym *pcl; /* pending cleanup goto */
! 		    for (pcl = s->next; pcl; pcl = pcl->prev)
! 		      gsym(pcl->jnext);
! 		    sym_pop(&s->next, NULL, 0);
  		} else
! 		  gsym(s->jnext);
              } else {
                  s = label_push(&global_label_stack, t, LABEL_DEFINED);
              }
!             s->jnext = gind(0);
!             s->cleanupstate = cur_scope->cl.s;
  
      block_after_label:
                {
--- 7050,7067 ----
                  if (s->r == LABEL_DEFINED)
                      tcc_error("duplicate label '%s'", get_tok_str(s->v, NULL));
                  s->r = LABEL_DEFINED;
! 		if (s->e.next) {
  		    Sym *pcl; /* pending cleanup goto */
! 		    for (pcl = s->e.next; pcl; pcl = pcl->prev)
! 		      gsym(pcl->b.a.a.jnext);
! 		    sym_pop(&s->e.next, NULL, 0);
  		} else
! 		  gsym(s->b.a.a.jnext);
              } else {
                  s = label_push(&global_label_stack, t, LABEL_DEFINED);
              }
!             s->b.a.a.jnext = gind(0);
!             s->e.cleanupstate = cur_scope->cl.s;
  
      block_after_label:
                {
***************
*** 7149,7155 ****
  	   (compound literals).  */
          if (((vtop->r & (VT_VALMASK | VT_LVAL)) != VT_CONST
               && ((vtop->r & (VT_SYM|VT_LVAL)) != (VT_SYM|VT_LVAL)
!                  || vtop->sym->v < SYM_FIRST_ANOM))
  #ifdef TCC_TARGET_PE
                   || ((vtop->r & VT_SYM) && vtop->sym->a.dllimport)
  #endif
--- 7151,7157 ----
  	   (compound literals).  */
          if (((vtop->r & (VT_VALMASK | VT_LVAL)) != VT_CONST
               && ((vtop->r & (VT_SYM|VT_LVAL)) != (VT_SYM|VT_LVAL)
!                  || vtop->b.sym->v < SYM_FIRST_ANOM))
  #ifdef TCC_TARGET_PE
                   || ((vtop->r & VT_SYM) && vtop->sym->a.dllimport)
  #endif
***************
*** 7222,7230 ****
  static void decl_design_flex(init_params *p, Sym *ref, int index)
  {
      if (ref == p->flex_array_ref) {
!         if (index >= ref->c)
!             ref->c = index + 1;
!     } else if (ref->c < 0)
          tcc_error("flexible array has zero size in this context");
  }
  
--- 7224,7232 ----
  static void decl_design_flex(init_params *p, Sym *ref, int index)
  {
      if (ref == p->flex_array_ref) {
!         if (index >= ref->b.a.c)
!             ref->b.a.c = index + 1;
!     } else if (ref->b.a.c < 0)
          tcc_error("flexible array has zero size in this context");
  }
  
***************
*** 7268,7277 ****
              skip(']');
              s = type->ref;
              decl_design_flex(p, s, index_last);
!             if (index < 0 || index_last >= s->c || index_last < index)
  	        tcc_error("index exceeds array bounds or range is empty");
              if (cur_field)
! 		(*cur_field)->c = index_last;
              type = pointed_type(type);
              elem_size = type_size(type, &align);
              c += index * elem_size;
--- 7270,7279 ----
              skip(']');
              s = type->ref;
              decl_design_flex(p, s, index_last);
!             if (index < 0 || index_last >= s->b.a.c || index_last < index)
  	        tcc_error("index exceeds array bounds or range is empty");
              if (cur_field)
! 		(*cur_field)->b.a.c = index_last;
              type = pointed_type(type);
              elem_size = type_size(type, &align);
              c += index * elem_size;
***************
*** 7291,7297 ****
              if (cur_field)
                  *cur_field = f;
  	    type = &f->type;
!             c += cumofs + f->c;
          }
          cur_field = NULL;
      }
--- 7293,7299 ----
              if (cur_field)
                  *cur_field = f;
  	    type = &f->type;
!             c += cumofs + f->b.a.c;
          }
          cur_field = NULL;
      }
***************
*** 7304,7313 ****
      } else {
      no_designator:
          if (type->t & VT_ARRAY) {
! 	    index = (*cur_field)->c;
              s = type->ref;
              decl_design_flex(p, s, index);
!             if (index >= s->c)
                  tcc_error("too many initializers");
              type = pointed_type(type);
              elem_size = type_size(type, &align);
--- 7306,7315 ----
      } else {
      no_designator:
          if (type->t & VT_ARRAY) {
! 	    index = (*cur_field)->b.a.c;
              s = type->ref;
              decl_design_flex(p, s, index);
!             if (index >= s->b.a.c)
                  tcc_error("too many initializers");
              type = pointed_type(type);
              elem_size = type_size(type, &align);
***************
*** 7315,7325 ****
          } else {
              f = *cur_field;
  	    while (f && (f->v & SYM_FIRST_ANOM) && (f->type.t & VT_BITFIELD))
! 	        *cur_field = f = f->next;
              if (!f)
                  tcc_error("too many initializers");
  	    type = &f->type;
!             c += f->c;
          }
      }
  
--- 7317,7327 ----
          } else {
              f = *cur_field;
  	    while (f && (f->v & SYM_FIRST_ANOM) && (f->type.t & VT_BITFIELD))
! 	        *cur_field = f = f->e.next;
              if (!f)
                  tcc_error("too many initializers");
  	    type = &f->type;
!             c += f->b.a.c;
          }
      }
  
***************
*** 7342,7348 ****
          int i;
          if (p->sec || (type->t & VT_ARRAY)) {
              /* make init_putv/vstore believe it were a struct */
!             aref.c = elem_size;
              t1.t = VT_STRUCT, t1.ref = &aref;
              type = &t1;
          }
--- 7344,7350 ----
          int i;
          if (p->sec || (type->t & VT_ARRAY)) {
              /* make init_putv/vstore believe it were a struct */
!             aref.b.a.c = elem_size;
              t1.t = VT_STRUCT, t1.ref = &aref;
              type = &t1;
          }
***************
*** 7391,7397 ****
              && bt != VT_PTR
              && (bt != (PTR_SIZE == 8 ? VT_LLONG : VT_INT)
                  || (type->t & VT_BITFIELD))
!             && !((vtop->r & VT_CONST) && vtop->sym->v >= SYM_FIRST_ANOM)
              )
              tcc_error("initializer element is not computable at load time");
  
--- 7393,7399 ----
              && bt != VT_PTR
              && (bt != (PTR_SIZE == 8 ? VT_LLONG : VT_INT)
                  || (type->t & VT_BITFIELD))
!             && !((vtop->r & VT_CONST) && vtop->b.sym->v >= SYM_FIRST_ANOM)
              )
              tcc_error("initializer element is not computable at load time");
  
***************
*** 7401,7411 ****
          }
  
          ptr = sec->data + c;
!         val = vtop->c.i;
  
          /* XXX: make code faster ? */
  	if ((vtop->r & (VT_SYM|VT_CONST)) == (VT_SYM|VT_CONST) &&
! 	    vtop->sym->v >= SYM_FIRST_ANOM &&
  	    /* XXX This rejects compound literals like
  	       '(void *){ptr}'.  The problem is that '&sym' is
  	       represented the same way, which would be ruled out
--- 7403,7413 ----
          }
  
          ptr = sec->data + c;
!         val = vtop->a.c.i;
  
          /* XXX: make code faster ? */
  	if ((vtop->r & (VT_SYM|VT_CONST)) == (VT_SYM|VT_CONST) &&
! 	    vtop->b.sym->v >= SYM_FIRST_ANOM &&
  	    /* XXX This rejects compound literals like
  	       '(void *){ptr}'.  The problem is that '&sym' is
  	       represented the same way, which would be ruled out
***************
*** 7421,7429 ****
  	    Section *ssec;
  	    ElfSym *esym;
  	    ElfW_Rel *rel;
! 	    esym = elfsym(vtop->sym);
  	    ssec = tcc_state->sections[esym->st_shndx];
! 	    memmove (ptr, ssec->data + esym->st_value + (int)vtop->c.i, size);
  	    if (ssec->reloc) {
  		/* We need to copy over all memory contents, and that
  		   includes relocations.  Use the fact that relocs are
--- 7423,7431 ----
  	    Section *ssec;
  	    ElfSym *esym;
  	    ElfW_Rel *rel;
! 	    esym = elfsym(vtop->b.sym);
  	    ssec = tcc_state->sections[esym->st_shndx];
! 	    memmove (ptr, ssec->data + esym->st_value + (int)vtop->a.c.i, size);
  	    if (ssec->reloc) {
  		/* We need to copy over all memory contents, and that
  		   includes relocations.  Use the fact that relocs are
***************
*** 7493,7513 ****
                     In any case we avoid possibly random bytes 11 and 12.
                  */
                  if (sizeof (long double) >= 10)
!                     memcpy(ptr, &vtop->c.ld, 10);
  #ifdef __TINYC__
                  else if (sizeof (long double) == sizeof (double))
                      __asm__("fldl %1\nfstpt %0\n" : "=m" (*ptr) : "m" (vtop->c.ld));
  #endif
!                 else if (vtop->c.ld == 0.0)
                      ;
                  else
  #endif
                  /* For other platforms it should work natively, but may not work
                     for cross compilers */
                  if (sizeof(long double) == LDOUBLE_SIZE)
!                     memcpy(ptr, &vtop->c.ld, LDOUBLE_SIZE);
                  else if (sizeof(double) == LDOUBLE_SIZE)
!                     memcpy(ptr, &vtop->c.ld, LDOUBLE_SIZE);
  #ifndef TCC_CROSS_TEST
                  else
                      tcc_error("can't cross compile long double constants");
--- 7495,7515 ----
                     In any case we avoid possibly random bytes 11 and 12.
                  */
                  if (sizeof (long double) >= 10)
!                     memcpy(ptr, &vtop->a.c.ld, 10);
  #ifdef __TINYC__
                  else if (sizeof (long double) == sizeof (double))
                      __asm__("fldl %1\nfstpt %0\n" : "=m" (*ptr) : "m" (vtop->c.ld));
  #endif
!                 else if (vtop->a.c.ld == 0.0)
                      ;
                  else
  #endif
                  /* For other platforms it should work natively, but may not work
                     for cross compilers */
                  if (sizeof(long double) == LDOUBLE_SIZE)
!                     memcpy(ptr, &vtop->a.c.ld, LDOUBLE_SIZE);
                  else if (sizeof(double) == LDOUBLE_SIZE)
!                     memcpy(ptr, &vtop->a.c.ld, LDOUBLE_SIZE);
  #ifndef TCC_CROSS_TEST
                  else
                      tcc_error("can't cross compile long double constants");
***************
*** 7533,7544 ****
              case VT_PTR:
              case VT_INT:
  	        if (vtop->r & VT_SYM)
! 	          greloc(sec, vtop->sym, c, R_DATA_PTR);
  	        write32le(ptr, val);
  	        break;
  #endif
  	    default:
!                 //tcc_internal_error("unexpected type");
                  break;
  	    }
  	}
--- 7535,7546 ----
              case VT_PTR:
              case VT_INT:
  	        if (vtop->r & VT_SYM)
! 	          greloc(sec, vtop->b.sym, c, R_DATA_PTR);
  	        write32le(ptr, val);
  	        break;
  #endif
  	    default:
!                 /* //tcc_internal_error("unexpected type"); */
                  break;
  	    }
  	}
***************
*** 7597,7603 ****
          }
  
          s = type->ref;
!         n = s->c;
          t1 = pointed_type(type);
          size1 = type_size(t1, &align1);
  
--- 7599,7605 ----
          }
  
          s = type->ref;
!         n = s->b.a.c;
          t1 = pointed_type(type);
          size1 = type_size(t1, &align1);
  
***************
*** 7672,7678 ****
          } else {
  
            do_init_array:
! 	    indexsym.c = 0;
  	    f = &indexsym;
  
            do_init_list:
--- 7674,7680 ----
          } else {
  
            do_init_array:
! 	    indexsym.b.a.c = 0;
  	    f = &indexsym;
  
            do_init_list:
***************
*** 7691,7697 ****
  		len = decl_designator(p, type, c, &f, flags, len);
  		flags &= ~DIF_HAVE_ELEM;
  		if (type->t & VT_ARRAY) {
! 		    ++indexsym.c;
  		    /* special test for multi dimensional arrays (may not
  		       be strictly correct if designators are used at the
  		       same time) */
--- 7693,7699 ----
  		len = decl_designator(p, type, c, &f, flags, len);
  		flags &= ~DIF_HAVE_ELEM;
  		if (type->t & VT_ARRAY) {
! 		    ++indexsym.b.a.c;
  		    /* special test for multi dimensional arrays (may not
  		       be strictly correct if designators are used at the
  		       same time) */
***************
*** 7701,7707 ****
  		    if (s->type.t == VT_UNION)
  		        f = NULL;
  		    else
! 		        f = f->next;
  		    if (no_oblock && f == NULL)
  		        break;
  		}
--- 7703,7709 ----
  		    if (s->type.t == VT_UNION)
  		        f = NULL;
  		    else
! 		        f = f->e.next;
  		    if (no_oblock && f == NULL)
  		        break;
  		}
***************
*** 7728,7735 ****
              no_oblock = 0;
          }
          s = type->ref;
!         f = s->next;
!         n = s->c;
          size1 = 1;
  	goto do_init_list;
  
--- 7730,7737 ----
              no_oblock = 0;
          }
          s = type->ref;
!         f = s->e.next;
!         n = s->b.a.c;
          size1 = 1;
  	goto do_init_list;
  
***************
*** 7764,7770 ****
  	}
          if (!p->sec && (flags & DIF_CLEAR) /* container was already zero'd */
              && (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST
!             && vtop->c.i == 0
              && btype_size(type->t & VT_BTYPE) /* not for fp constants */
              )
              vpop();
--- 7766,7772 ----
  	}
          if (!p->sec && (flags & DIF_CLEAR) /* container was already zero'd */
              && (vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST
!             && vtop->a.c.i == 0
              && btype_size(type->t & VT_BTYPE) /* not for fp constants */
              )
              vpop();
***************
*** 7810,7824 ****
             (like in 'typedef int arr[]; arr x = {1};') then we will
             overwrite the unknown size by the real one for this decl.
             We need to unshare the ref symbol holding that size. */
!         type->ref = sym_push(SYM_FIELD, &type->ref->type, 0, type->ref->c);
          p.flex_array_ref = type->ref;
  
      } else if (has_init && (type->t & VT_BTYPE) == VT_STRUCT) {
!         Sym *field = type->ref->next;
          if (field) {
!             while (field->next)
!                 field = field->next;
!             if (field->type.t & VT_ARRAY && field->type.ref->c < 0) {
                  flexible_array = field;
                  p.flex_array_ref = field->type.ref;
                  size = -1;
--- 7812,7826 ----
             (like in 'typedef int arr[]; arr x = {1};') then we will
             overwrite the unknown size by the real one for this decl.
             We need to unshare the ref symbol holding that size. */
!         type->ref = sym_push(SYM_FIELD, &type->ref->type, 0, type->ref->b.a.c);
          p.flex_array_ref = type->ref;
  
      } else if (has_init && (type->t & VT_BTYPE) == VT_STRUCT) {
!         Sym *field = type->ref->e.next;
          if (field) {
!             while (field->e.next)
!                 field = field->e.next;
!             if (field->type.t & VT_ARRAY && field->type.ref->b.a.c < 0) {
                  flexible_array = field;
                  p.flex_array_ref = field->type.ref;
                  size = -1;
***************
*** 7858,7865 ****
  
          /* If there's a flex member and it was used in the initializer
             adjust size.  */
!         if (flexible_array && flexible_array->type.ref->c > 0)
!             size += flexible_array->type.ref->c
                      * pointed_size(&flexible_array->type);
      }
  
--- 7860,7867 ----
  
          /* If there's a flex member and it was used in the initializer
             adjust size.  */
!         if (flexible_array && flexible_array->type.ref->b.a.c > 0)
!             size += flexible_array->type.ref->b.a.c
                      * pointed_size(&flexible_array->type);
      }
  
***************
*** 7906,7913 ****
  		Sym *cls = sym_push2(&all_cleanups,
                      SYM_FIELD | ++cur_scope->cl.n, 0, 0);
  		cls->prev_tok = sym;
! 		cls->next = ad->cleanup_func;
! 		cls->ncl = cur_scope->cl.s;
  		cur_scope->cl.s = cls;
  	    }
  
--- 7908,7915 ----
  		Sym *cls = sym_push2(&all_cleanups,
                      SYM_FIELD | ++cur_scope->cl.n, 0, 0);
  		cls->prev_tok = sym;
! 		cls->e.next = ad->cleanup_func;
! 		cls->b.ncl = cur_scope->cl.s;
  		cur_scope->cl.s = cls;
  	    }
  
***************
*** 7923,7938 ****
              sym = sym_find(v);
              if (sym) {
                  if (p.flex_array_ref && (sym->type.t & type->t & VT_ARRAY)
!                     && sym->type.ref->c > type->ref->c) {
                      /* flex array was already declared with explicit size
                              extern int arr[10];
                              int arr[] = { 1,2,3 }; */
!                     type->ref->c = sym->type.ref->c;
                      size = type_size(type, &align);
                  }
                  patch_storage(sym, ad, type);
                  /* we accept several definitions of the same global variable. */
!                 if (!has_init && sym->c && elfsym(sym)->st_shndx != SHN_UNDEF)
                      goto no_alloc;
              }
          }
--- 7925,7940 ----
              sym = sym_find(v);
              if (sym) {
                  if (p.flex_array_ref && (sym->type.t & type->t & VT_ARRAY)
!                     && sym->type.ref->b.a.c > type->ref->b.a.c) {
                      /* flex array was already declared with explicit size
                              extern int arr[10];
                              int arr[] = { 1,2,3 }; */
!                     type->ref->b.a.c = sym->type.ref->b.a.c;
                      size = type_size(type, &align);
                  }
                  patch_storage(sym, ad, type);
                  /* we accept several definitions of the same global variable. */
!                 if (!has_init && sym->b.a.c && elfsym(sym)->st_shndx != SHN_UNDEF)
                      goto no_alloc;
              }
          }
***************
*** 7975,7981 ****
          } else {
              /* push global reference */
              vpush_ref(type, sec, addr, size);
!             sym = vtop->sym;
  	    vtop->r |= r;
          }
  
--- 7977,7983 ----
          } else {
              /* push global reference */
              vpush_ref(type, sec, addr, size);
!             sym = vtop->b.sym;
  	    vtop->r |= r;
          }
  
***************
*** 8026,8032 ****
          /* patch flexible array member size back to -1, */
          /* for possible subsequent similar declarations */
          if (flexible_array)
!             flexible_array->type.ref->c = -1;
      }
  
   no_alloc:
--- 8028,8034 ----
          /* patch flexible array member size back to -1, */
          /* for possible subsequent similar declarations */
          if (flexible_array)
!             flexible_array->type.ref->b.a.c = -1;
      }
  
   no_alloc:
***************
*** 8048,8061 ****
      if (arg->type.ref)
          func_vla_arg_code(arg->type.ref);
  
!     if ((arg->type.t & VT_VLA) && arg->type.ref->vla_array_str) {
  	loc -= type_size(&int_type, &align);
  	loc &= -align;
! 	arg->type.ref->c = loc;
  
  	unget_tok(0);
  	vla_array_tok = tok_str_alloc();
! 	vla_array_tok->str = arg->type.ref->vla_array_str;
  	begin_macro(vla_array_tok, 1);
  	next();
  	gexpr();
--- 8050,8063 ----
      if (arg->type.ref)
          func_vla_arg_code(arg->type.ref);
  
!     if ((arg->type.t & VT_VLA) && arg->type.ref->e.vla_array_str) {
  	loc -= type_size(&int_type, &align);
  	loc &= -align;
! 	arg->type.ref->b.a.c = loc;
  
  	unget_tok(0);
  	vla_array_tok = tok_str_alloc();
! 	vla_array_tok->str = arg->type.ref->e.vla_array_str;
  	begin_macro(vla_array_tok, 1);
  	next();
  	gexpr();
***************
*** 8063,8069 ****
  	next();
  	vpush_type_size(&arg->type.ref->type, &align);
  	gen_op('*');
! 	vset(&int_type, VT_LOCAL|VT_LVAL, arg->type.ref->c);
  	vswap();
  	vstore();
  	vpop();
--- 8065,8071 ----
  	next();
  	vpush_type_size(&arg->type.ref->type, &align);
  	gen_op('*');
! 	vset(&int_type, VT_LOCAL|VT_LVAL, arg->type.ref->b.a.c);
  	vswap();
  	vstore();
  	vpop();
***************
*** 8074,8080 ****
  {
      Sym *arg;
  
!     for (arg = sym->type.ref->next; arg; arg = arg->next)
  	if (arg->type.t & VT_VLA)
  	    func_vla_arg_code(arg);
  }
--- 8076,8082 ----
  {
      Sym *arg;
  
!     for (arg = sym->type.ref->e.next; arg; arg = arg->e.next)
  	if (arg->type.t & VT_VLA)
  	    func_vla_arg_code(arg);
  }
***************
*** 8094,8108 ****
      }
      /* NOTE: we patch the symbol size later */
      put_extern_sym(sym, cur_text_section, ind, 0);
!     if (sym->type.ref->f.func_ctor)
!         add_array (tcc_state, ".init_array", sym->c);
!     if (sym->type.ref->f.func_dtor)
!         add_array (tcc_state, ".fini_array", sym->c);
  
      funcname = get_tok_str(sym->v, NULL);
      func_ind = ind;
      func_vt = sym->type.ref->type;
!     func_var = sym->type.ref->f.func_type == FUNC_ELLIPSIS;
  
      /* put debug symbol */
      tcc_debug_funcstart(tcc_state, sym);
--- 8096,8110 ----
      }
      /* NOTE: we patch the symbol size later */
      put_extern_sym(sym, cur_text_section, ind, 0);
!     if (sym->type.ref->b.a.a.f.func_ctor)
!         add_array (tcc_state, ".init_array", sym->b.a.c);
!     if (sym->type.ref->b.a.a.f.func_dtor)
!         add_array (tcc_state, ".fini_array", sym->b.a.c);
  
      funcname = get_tok_str(sym->v, NULL);
      func_ind = ind;
      func_vt = sym->type.ref->type;
!     func_var = sym->type.ref->b.a.a.f.func_type == FUNC_ELLIPSIS;
  
      /* put debug symbol */
      tcc_debug_funcstart(tcc_state, sym);
***************
*** 8154,8160 ****
          for (i = 0; i < s->nb_inline_fns; ++i) {
              fn = s->inline_fns[i];
              sym = fn->sym;
!             if (sym && (sym->c || !(sym->type.t & VT_INLINE))) {
                  /* the function was used or forced (and then not internal):
                     generate its code and convert it to a normal function */
                  fn->sym = NULL;
--- 8156,8162 ----
          for (i = 0; i < s->nb_inline_fns; ++i) {
              fn = s->inline_fns[i];
              sym = fn->sym;
!             if (sym && (sym->b.a.c || !(sym->type.t & VT_INLINE))) {
                  /* the function was used or forced (and then not internal):
                     generate its code and convert it to a normal function */
                  fn->sym = NULL;
***************
*** 8279,8285 ****
                  /* if old style function prototype, we accept a
                     declaration list */
                  sym = type.ref;
!                 if (sym->f.func_type == FUNC_OLD && l == VT_CONST)
                      decl0(VT_CMP, 0, sym);
  #if defined TCC_TARGET_MACHO || defined TARGETOS_ANDROID
                  if (sym->f.func_alwinl
--- 8281,8287 ----
                  /* if old style function prototype, we accept a
                     declaration list */
                  sym = type.ref;
!                 if (sym->b.a.a.f.func_type == FUNC_OLD && l == VT_CONST)
                      decl0(VT_CMP, 0, sym);
  #if defined TCC_TARGET_MACHO || defined TARGETOS_ANDROID
                  if (sym->f.func_alwinl
***************
*** 8287,8293 ****
                          == (VT_EXTERN | VT_INLINE))) {
                      /* always_inline functions must be handled as if they
                         don't generate multiple global defs, even if extern
!                        inline, i.e. GNU inline semantics for those.  Rewrite
                         them into static inline.  */
                      type.t &= ~VT_EXTERN;
                      type.t |= VT_STATIC;
--- 8289,8295 ----
                          == (VT_EXTERN | VT_INLINE))) {
                      /* always_inline functions must be handled as if they
                         don't generate multiple global defs, even if extern
!                        inline, i.e. GNU semantics for those.  Rewrite
                         them into static inline.  */
                      type.t &= ~VT_EXTERN;
                      type.t |= VT_STATIC;
***************
*** 8338,8344 ****
                  /* reject abstract declarators in function definition
                     make old style params without decl have int type */
                  sym = type.ref;
!                 while ((sym = sym->next) != NULL) {
                      if (!(sym->v & ~SYM_FIELD))
                          expect("identifier");
                      if (sym->type.t == VT_VOID)
--- 8340,8346 ----
                  /* reject abstract declarators in function definition
                     make old style params without decl have int type */
                  sym = type.ref;
!                 while ((sym = sym->e.next) != NULL) {
                      if (!(sym->v & ~SYM_FIELD))
                          expect("identifier");
                      if (sym->type.t == VT_VOID)
***************
*** 8346,8352 ****
                  }
  
                  /* apply post-declaraton attributes */
!                 merge_funcattr(&type.ref->f, &ad.f);
  
                  /* put function symbol */
                  type.t &= ~VT_EXTERN;
--- 8348,8354 ----
                  }
  
                  /* apply post-declaraton attributes */
!                 merge_funcattr(&type.ref->b.a.a.f, &ad.f);
  
                  /* put function symbol */
                  type.t &= ~VT_EXTERN;
***************
*** 8374,8380 ****
              } else {
  		if (l == VT_CMP) {
  		    /* find parameter in function parameter list */
! 		    for (sym = func_sym->next; sym; sym = sym->next)
  			if ((sym->v & ~SYM_FIELD) == v)
  			    goto found;
  		    tcc_error("declaration for parameter '%s' but no such parameter",
--- 8376,8382 ----
              } else {
  		if (l == VT_CMP) {
  		    /* find parameter in function parameter list */
! 		    for (sym = func_sym->e.next; sym; sym = sym->e.next)
  			if ((sym->v & ~SYM_FIELD) == v)
  			    goto found;
  		    tcc_error("declaration for parameter '%s' but no such parameter",
***************
*** 8392,8398 ****
                      /* save typedefed type  */
                      /* XXX: test storage specifiers ? */
                      sym = sym_find(v);
!                     if (sym && sym->sym_scope == local_scope) {
                          if (!is_compatible_types(&sym->type, &type)
                              || !(sym->type.t & VT_TYPEDEF))
                              tcc_error("incompatible redefinition of '%s'",
--- 8394,8400 ----
                      /* save typedefed type  */
                      /* XXX: test storage specifiers ? */
                      sym = sym_find(v);
!                     if (sym && sym->b.a.a.sym_scope == local_scope) {
                          if (!is_compatible_types(&sym->type, &type)
                              || !(sym->type.t & VT_TYPEDEF))
                              tcc_error("incompatible redefinition of '%s'",
***************
*** 8402,8408 ****
                          sym = sym_push(v, &type, 0, 0);
                      }
                      sym->a = ad.a;
!                     sym->f = ad.f;
                      if (debug_modes)
                          tcc_debug_typedef (tcc_state, sym);
  		} else if ((type.t & VT_BTYPE) == VT_VOID
--- 8404,8410 ----
                          sym = sym_push(v, &type, 0, 0);
                      }
                      sym->a = ad.a;
!                     sym->b.a.a.f = ad.f;
                      if (debug_modes)
                          tcc_debug_typedef (tcc_state, sym);
  		} else if ((type.t & VT_BTYPE) == VT_VOID
***************
*** 8413,8419 ****
                      if ((type.t & VT_BTYPE) == VT_FUNC) {
                          /* external function definition */
                          /* specific case for func_call attribute */
!                         type.ref->f = ad.f;
                      } else if (!(type.t & VT_ARRAY)) {
                          /* not lvalue if array */
                          r |= VT_LVAL;
--- 8415,8421 ----
                      if ((type.t & VT_BTYPE) == VT_FUNC) {
                          /* external function definition */
                          /* specific case for func_call attribute */
!                         type.ref->b.a.a.f = ad.f;
                      } else if (!(type.t & VT_ARRAY)) {
                          /* not lvalue if array */
                          r |= VT_LVAL;
***************
*** 8426,8432 ****
                          /* as with GCC, uninitialized global arrays with no size
                             are considered extern: */
                          || ((type.t & VT_ARRAY) && !has_init
!                             && l == VT_CONST && type.ref->c < 0)
                          ) {
                          /* external variable or function */
                          type.t |= VT_EXTERN;
--- 8428,8434 ----
                          /* as with GCC, uninitialized global arrays with no size
                             are considered extern: */
                          || ((type.t & VT_ARRAY) && !has_init
!                             && l == VT_CONST && type.ref->b.a.c < 0)
                          ) {
                          /* external variable or function */
                          type.t |= VT_EXTERN;
diff -r -N -c a/tcc.h b/tcc.h
*** a/tcc.h	2022-08-18 09:34:36.000000000 +0000
--- b/tcc.h	2023-02-02 13:38:12.705291626 +0000
***************
*** 50,55 ****
--- 50,56 ----
  extern long double strtold (const char *__nptr, char **__endptr);
  #endif
  
+ # define inline
  #ifdef _WIN32
  # define WIN32_LEAN_AND_MEAN 1
  # include <windows.h>
***************
*** 59,65 ****
  # ifdef __GNUC__
  #  include <stdint.h>
  # endif
- # define inline __inline
  # define snprintf _snprintf
  # define vsnprintf _vsnprintf
  # ifndef __GNUC__
--- 60,65 ----
***************
*** 518,557 ****
      unsigned short r2;     /* second register, used for 'long long'
                                type. If not used, set to VT_CONST */
      union {
!       struct { int jtrue, jfalse; }; /* forward jmps */
        CValue c;         /* constant, if VT_CONST */
!     };
      union {
!       struct { unsigned short cmp_op, cmp_r; }; /* VT_CMP operation */
        struct Sym *sym;  /* symbol, if (VT_SYM | VT_CONST), or if */
!     };                  /* result of unary() for an identifier. */
  
  } SValue;
  
  /* symbol attributes */
  struct SymAttr {
!     unsigned short
!     aligned     : 5, /* alignment as log2+1 (0 == unspecified) */
!     packed      : 1,
!     weak        : 1,
!     visibility  : 2,
!     dllexport   : 1,
!     nodecorate  : 1,
!     dllimport   : 1,
!     addrtaken   : 1,
      xxxx        : 3; /* not used */
  };
  
  /* function attributes or temporary attributes for parsing */
  struct FuncAttr {
!     unsigned
!     func_call   : 3, /* calling convention (0..5), see below */
!     func_type   : 2, /* FUNC_OLD/NEW/ELLIPSIS */
!     func_noreturn : 1, /* attribute((noreturn)) */
!     func_ctor   : 1, /* attribute((constructor)) */
!     func_dtor   : 1, /* attribute((destructor)) */
!     func_args   : 8, /* PE __stdcall args */
!     func_alwinl : 1, /* always_inline */
      xxxx        : 15;
  };
  
--- 518,557 ----
      unsigned short r2;     /* second register, used for 'long long'
                                type. If not used, set to VT_CONST */
      union {
!       struct { int jtrue, jfalse; } a; /* forward jmps */
        CValue c;         /* constant, if VT_CONST */
!     } a;
      union {
!       struct { unsigned short cmp_op, cmp_r; } b; /* VT_CMP operation */
        struct Sym *sym;  /* symbol, if (VT_SYM | VT_CONST), or if */
!     } b;                  /* result of unary() for an identifier. */
  
  } SValue;
  
  /* symbol attributes */
  struct SymAttr {
!     int
!     aligned     : 6, /* alignment as log2+1 (0 == unspecified) */
!     packed      : 2,
!     weak        : 2,
!     visibility  : 3,
!     dllexport   : 2,
!     nodecorate  : 2,
!     dllimport   : 2,
!     addrtaken   : 2,
      xxxx        : 3; /* not used */
  };
  
  /* function attributes or temporary attributes for parsing */
  struct FuncAttr {
!     int
!     func_call   : 4, /* calling convention (0..5), see below */
!     func_type   : 3, /* FUNC_OLD/NEW/ELLIPSIS */
!     func_noreturn : 2, /* attribute((noreturn)) */
!     func_ctor   : 2, /* attribute((constructor)) */
!     func_dtor   : 2, /* attribute((destructor)) */
!     func_args   : 9, /* PE __stdcall args */
!     func_alwinl : 2, /* always_inline */
      xxxx        : 15;
  };
  
***************
*** 568,586 ****
                  int jnext; /* next jump label */
                  struct FuncAttr f; /* function attributes */
                  int auxtype; /* bitfield access type */
!             };
!         };
          long long enum_val; /* enum constant if IS_ENUM_VAL */
          int *d; /* define token stream */
          struct Sym *ncl; /* next cleanup */
!     };
      CType type; /* associated type */
      union {
          int *vla_array_str; /* vla array code */
          struct Sym *next; /* next related symbol (for fields and anoms) */
          struct Sym *cleanupstate; /* in defined labels */
          int asm_label; /* associated asm label */
!     };
      struct Sym *prev; /* prev symbol in stack */
      struct Sym *prev_tok; /* previous symbol for this token */
  } Sym;
--- 568,586 ----
                  int jnext; /* next jump label */
                  struct FuncAttr f; /* function attributes */
                  int auxtype; /* bitfield access type */
!             } a;
!         } a;
          long long enum_val; /* enum constant if IS_ENUM_VAL */
          int *d; /* define token stream */
          struct Sym *ncl; /* next cleanup */
!     } b;
      CType type; /* associated type */
      union {
          int *vla_array_str; /* vla array code */
          struct Sym *next; /* next related symbol (for fields and anoms) */
          struct Sym *cleanupstate; /* in defined labels */
          int asm_label; /* associated asm label */
!     } e;
      struct Sym *prev; /* prev symbol in stack */
      struct Sym *prev_tok; /* previous symbol for this token */
  } Sym;
diff -r -N -c a/tccpp.c b/tccpp.c
*** a/tccpp.c	2022-08-18 09:34:36.000000000 +0000
--- b/tccpp.c	2023-02-02 11:27:56.011803724 +0000
***************
*** 127,133 ****
  #define TAL_DEBUG_PARAMS
  #else
  #define TAL_DEBUG 1
! //#define TAL_INFO 1 /* collect and dump allocators stats */
  #define tal_free(al, p) tal_free_impl(al, p, __FILE__, __LINE__)
  #define tal_realloc(al, p, size) tal_realloc_impl(&al, p, size, __FILE__, __LINE__)
  #define TAL_DEBUG_PARAMS , const char *file, int line
--- 127,133 ----
  #define TAL_DEBUG_PARAMS
  #else
  #define TAL_DEBUG 1
! /* //#define TAL_INFO 1 //collect and dump allocators stats */
  #define tal_free(al, p) tal_free_impl(al, p, __FILE__, __LINE__)
  #define tal_realloc(al, p, size) tal_realloc_impl(&al, p, size, __FILE__, __LINE__)
  #define TAL_DEBUG_PARAMS , const char *file, int line
***************
*** 410,425 ****
  
  ST_FUNC int cstr_vprintf(CString *cstr, const char *fmt, va_list ap)
  {
-     va_list v;
      int len, size = 80;
      for (;;) {
          size += cstr->size;
          if (size > cstr->size_allocated)
              cstr_realloc(cstr, size);
          size = cstr->size_allocated - cstr->size;
!         va_copy(v, ap);
!         len = vsnprintf((char*)cstr->data + cstr->size, size, fmt, v);
!         va_end(v);
          if (len > 0 && len < size)
              break;
          size *= 2;
--- 410,422 ----
  
  ST_FUNC int cstr_vprintf(CString *cstr, const char *fmt, va_list ap)
  {
      int len, size = 80;
      for (;;) {
          size += cstr->size;
          if (size > cstr->size_allocated)
              cstr_realloc(cstr, size);
          size = cstr->size_allocated - cstr->size;
!         len = vsnprintf((char*)cstr->data + cstr->size, size, fmt, ap);
          if (len > 0 && len < size)
              break;
          size *= 2;
***************
*** 861,867 ****
              } else if (str) { /* not skipping */
                  goto unterminated_string;
              } else {
!                 //tcc_warning("missing terminating %c character", sep);
                  return p;
              }
          } else if (c == '\r') {
--- 858,864 ----
              } else if (str) { /* not skipping */
                  goto unterminated_string;
              } else {
!                 /* //tcc_warning("missing terminating %c character", sep); */
                  return p;
              }
          } else if (c == '\r') {
***************
*** 1290,1300 ****
  
      o = define_find(v);
      s = sym_push2(&define_stack, v, macro_type, 0);
!     s->d = str;
!     s->next = first_arg;
      table_ident[v - TOK_IDENT]->sym_define = s;
  
!     if (o && !macro_is_equal(o->d, s->d))
  	tcc_warning("%s redefined", get_tok_str(v, NULL));
  }
  
--- 1287,1297 ----
  
      o = define_find(v);
      s = sym_push2(&define_stack, v, macro_type, 0);
!     s->b.d = str;
!     s->e.next = first_arg;
      table_ident[v - TOK_IDENT]->sym_define = s;
  
!     if (o && !macro_is_equal(o->b.d, s->b.d))
  	tcc_warning("%s redefined", get_tok_str(v, NULL));
  }
  
***************
*** 1320,1326 ****
      while (define_stack != b) {
          Sym *top = define_stack;
          define_stack = top->prev;
!         tok_str_free_str(top->d);
          define_undef(top);
          sym_free(top);
      }
--- 1317,1323 ----
      while (define_stack != b) {
          Sym *top = define_stack;
          define_stack = top->prev;
!         tok_str_free_str(top->b.d);
          define_undef(top);
          sym_free(top);
      }
***************
*** 1365,1374 ****
                  tcc_error("label '%s' used but not defined",
                        get_tok_str(s->v, NULL));
          } else {
!             if (s->c) {
                  /* define corresponding symbol. A size of
                     1 is put. */
!                 put_extern_sym(s, cur_text_section, s->jnext, 1);
              }
          }
          /* remove label */
--- 1362,1371 ----
                  tcc_error("label '%s' used but not defined",
                        get_tok_str(s->v, NULL));
          } else {
!             if (s->b.a.c) {
                  /* define corresponding symbol. A size of
                     1 is put. */
!                 put_extern_sym(s, cur_text_section, s->b.a.a.jnext, 1);
              }
          }
          /* remove label */
***************
*** 1617,1623 ****
                  tcc_error("bad macro parameter list");
              s = sym_push2(&define_stack, varg | SYM_FIELD, is_vaargs, 0);
              *ps = s;
!             ps = &s->next;
              if (tok == ')')
                  break;
              if (tok != ',' || is_vaargs)
--- 1614,1620 ----
                  tcc_error("bad macro parameter list");
              s = sym_push2(&define_stack, varg | SYM_FIELD, is_vaargs, 0);
              *ps = s;
!             ps = &s->e.next;
              if (tok == ')')
                  break;
              if (tok != ',' || is_vaargs)
***************
*** 1737,1743 ****
                  }
          }
          if (s)
!             table_ident[v - TOK_IDENT]->sym_define = s->d ? s : NULL;
          else
              tcc_warning("unbalanced #pragma pop_macro");
          pp_debug_tok = t, pp_debug_symv = v;
--- 1734,1740 ----
                  }
          }
          if (s)
!             table_ident[v - TOK_IDENT]->sym_define = s->b.d ? s : NULL;
          else
              tcc_warning("unbalanced #pragma pop_macro");
          pp_debug_tok = t, pp_debug_symv = v;
***************
*** 2699,2704 ****
--- 2696,2702 ----
      case 'U': case 'V': case 'W': case 'X':
      case 'Y': case 'Z': 
      case '_':
+ ;
      parse_ident_fast:
          p1 = p;
          h = TOK_HASH_INIT;
***************
*** 3008,3014 ****
              if (s) {
                  cstr_new(&cstr);
                  cstr_ccat(&cstr, '\"');
!                 st = s->d;
                  spc = 0;
                  while (*st >= 0) {
                      TOK_GET(&t, &st, &cval);
--- 3006,3012 ----
              if (s) {
                  cstr_new(&cstr);
                  cstr_ccat(&cstr, '\"');
!                 st = s->b.d;
                  spc = 0;
                  while (*st >= 0) {
                      TOK_GET(&t, &st, &cval);
***************
*** 3044,3050 ****
              s = sym_find2(args, t);
              if (s) {
                  int l0 = str.len;
!                 st = s->d;
                  /* if '##' is present before or after, no arg substitution */
                  if (*macro_str == TOK_PPJOIN || t1 == TOK_PPJOIN) {
                      /* special case for var arg macros : ## eats the ','
--- 3042,3048 ----
              s = sym_find2(args, t);
              if (s) {
                  int l0 = str.len;
!                 st = s->b.d;
                  /* if '##' is present before or after, no arg substitution */
                  if (*macro_str == TOK_PPJOIN || t1 == TOK_PPJOIN) {
                      /* special case for var arg macros : ## eats the ','
***************
*** 3061,3079 ****
                      }
                  } else {
              add_var:
! 		    if (!s->next) {
  			/* Expand arguments tokens and store them.  In most
  			   cases we could also re-expand each argument if
  			   used multiple times, but not if the argument
  			   contains the __COUNTER__ macro.  */
  			TokenString str2;
! 			sym_push2(&s->next, s->v, s->type.t, 0);
  			tok_str_new(&str2);
  			macro_subst(&str2, nested_list, st);
  			tok_str_add(&str2, 0);
! 			s->next->d = str2.str;
  		    }
! 		    st = s->next->d;
                  }
                  for(;;) {
                      int t2;
--- 3059,3077 ----
                      }
                  } else {
              add_var:
! 		    if (!s->e.next) {
  			/* Expand arguments tokens and store them.  In most
  			   cases we could also re-expand each argument if
  			   used multiple times, but not if the argument
  			   contains the __COUNTER__ macro.  */
  			TokenString str2;
! 			sym_push2(&s->e.next, s->v, s->type.t, 0);
  			tok_str_new(&str2);
  			macro_subst(&str2, nested_list, st);
  			tok_str_add(&str2, 0);
! 			s->e.next->b.d = str2.str;
  		    }
! 		    st = s->e.next->b.d;
                  }
                  for(;;) {
                      int t2;
***************
*** 3130,3136 ****
          break;
      }
      tcc_close();
!     //printf("paste <%s>\n", (char*)cstr.data);
      cstr_free(&cstr);
      return ret;
  }
--- 3128,3134 ----
          break;
      }
      tcc_close();
!     /* //printf("paste <%s>\n", (char*)cstr.data); */
      cstr_free(&cstr);
      return ret;
  }
***************
*** 3156,3162 ****
  
      tok_str_new(&macro_str1);
  
!     //tok_print(" $$$", ptr0);
      for (ptr = ptr0;;) {
          TOK_GET(&t, &ptr, &cval);
          if (t == 0)
--- 3154,3160 ----
  
      tok_str_new(&macro_str1);
  
!     /* //tok_print(" $$$", ptr0); */
      for (ptr = ptr0;;) {
          TOK_GET(&t, &ptr, &cval);
          if (t == 0)
***************
*** 3192,3198 ****
          tok_str_add2(&macro_str1, t, &cval);
      }
      tok_str_add(&macro_str1, 0);
!     //tok_print(" ###", macro_str1.str);
      return macro_str1.str;
  }
  
--- 3190,3196 ----
          tok_str_add2(&macro_str1, t, &cval);
      }
      tok_str_add(&macro_str1, 0);
!     /* //tok_print(" ###", macro_str1.str); */
      return macro_str1.str;
  }
  
***************
*** 3291,3300 ****
          time(&ti);
          tm = localtime(&ti);
          if (tok == TOK___DATE__) {
!             snprintf(buf, sizeof(buf), "%s %2d %d", 
                       ab_month_name[tm->tm_mon], tm->tm_mday, tm->tm_year + 1900);
          } else {
!             snprintf(buf, sizeof(buf), "%02d:%02d:%02d", 
                       tm->tm_hour, tm->tm_min, tm->tm_sec);
          }
          cstrval = buf;
--- 3289,3298 ----
          time(&ti);
          tm = localtime(&ti);
          if (tok == TOK___DATE__) {
!             snprintf(buf, sizeof(buf), "%s %2d %d",
                       ab_month_name[tm->tm_mon], tm->tm_mday, tm->tm_year + 1900);
          } else {
!             snprintf(buf, sizeof(buf), "%02d:%02d:%02d",
                       tm->tm_hour, tm->tm_min, tm->tm_sec);
          }
          cstrval = buf;
***************
*** 3307,3316 ****
          cval.str.data = cstr.data;
          tok_str_add2(tok_str, t1, &cval);
          cstr_free(&cstr);
!     } else if (s->d) {
          int saved_parse_flags = parse_flags;
  	int *joined_str = NULL;
!         int *mstr = s->d;
  
          if (s->type.t == MACRO_FUNC) {
              /* whitespace between macro name and argument list */
--- 3305,3314 ----
          cval.str.data = cstr.data;
          tok_str_add2(tok_str, t1, &cval);
          cstr_free(&cstr);
!     } else if (s->b.d) {
          int saved_parse_flags = parse_flags;
  	int *joined_str = NULL;
!         int *mstr = s->b.d;
  
          if (s->type.t == MACRO_FUNC) {
              /* whitespace between macro name and argument list */
***************
*** 3346,3352 ****
  
              /* argument macro */
              args = NULL;
!             sa = s->next;
              /* NOTE: empty args are allowed, except if no args */
              for(;;) {
                  do {
--- 3344,3350 ----
  
              /* argument macro */
              args = NULL;
!             sa = s->e.next;
              /* NOTE: empty args are allowed, except if no args */
              for(;;) {
                  do {
***************
*** 3384,3391 ****
                  tok_str_add(&str, -1);
                  tok_str_add(&str, 0);
                  sa1 = sym_push2(&args, sa->v & ~SYM_FIELD, sa->type.t, 0);
!                 sa1->d = str.str;
!                 sa = sa->next;
                  if (tok == ')') {
                      /* special case for gcc var args: add an empty
                         var arg argument if it is omitted */
--- 3382,3389 ----
                  tok_str_add(&str, -1);
                  tok_str_add(&str, 0);
                  sa1 = sym_push2(&args, sa->v & ~SYM_FIELD, sa->type.t, 0);
!                 sa1->b.d = str.str;
!                 sa = sa->e.next;
                  if (tok == ')') {
                      /* special case for gcc var args: add an empty
                         var arg argument if it is omitted */
***************
*** 3407,3416 ****
              sa = args;
              while (sa) {
                  sa1 = sa->prev;
!                 tok_str_free_str(sa->d);
!                 if (sa->next) {
!                     tok_str_free_str(sa->next->d);
!                     sym_free(sa->next);
                  }
                  sym_free(sa);
                  sa = sa1;
--- 3405,3414 ----
              sa = args;
              while (sa) {
                  sa1 = sa->prev;
!                 tok_str_free_str(sa->b.d);
!                 if (sa->e.next) {
!                     tok_str_free_str(sa->e.next->b.d);
!                     sym_free(sa->e.next);
                  }
                  sym_free(sa);
                  sa = sa1;
***************
*** 3429,3435 ****
          sym_free(sa1);
  	if (joined_str)
  	    tok_str_free_str(joined_str);
!         if (mstr != s->d)
              tok_str_free_str(mstr);
      }
      return 0;
--- 3427,3433 ----
          sym_free(sa1);
  	if (joined_str)
  	    tok_str_free_str(joined_str);
!         if (mstr != s->b.d)
              tok_str_free_str(mstr);
      }
      return 0;
***************
*** 3712,3718 ****
            cstr_cat(&cstr, s1->cmdline_defs.data, s1->cmdline_defs.size);
          if (s1->cmdline_incl.size)
            cstr_cat(&cstr, s1->cmdline_incl.data, s1->cmdline_incl.size);
!         //printf("%s\n", (char*)cstr.data);
          *s1->include_stack_ptr++ = file;
          tcc_open_bf(s1, "<command line>", cstr.size);
          memcpy(file->buffer, cstr.data, cstr.size);
--- 3710,3716 ----
            cstr_cat(&cstr, s1->cmdline_defs.data, s1->cmdline_defs.size);
          if (s1->cmdline_incl.size)
            cstr_cat(&cstr, s1->cmdline_incl.data, s1->cmdline_incl.size);
!         /* //printf("%s\n", (char*)cstr.data); */
          *s1->include_stack_ptr++ = file;
          tcc_open_bf(s1, "<command line>", cstr.size);
          memcpy(file->buffer, cstr.data, cstr.size);
***************
*** 3866,3889 ****
      Sym *s;
  
      s = define_find(v);
!     if (NULL == s || NULL == s->d)
          return;
  
      fp = s1->ppfp;
      fprintf(fp, "#define %s", get_tok_str(v, NULL));
      if (s->type.t == MACRO_FUNC) {
!         Sym *a = s->next;
          fprintf(fp,"(");
          if (a)
              for (;;) {
                  fprintf(fp,"%s", get_tok_str(a->v & ~SYM_FIELD, NULL));
!                 if (!(a = a->next))
                      break;
                  fprintf(fp,",");
              }
          fprintf(fp,")");
      }
!     tok_print("", s->d);
  }
  
  static void pp_debug_defines(TCCState *s1)
--- 3864,3887 ----
      Sym *s;
  
      s = define_find(v);
!     if (NULL == s || NULL == s->b.d)
          return;
  
      fp = s1->ppfp;
      fprintf(fp, "#define %s", get_tok_str(v, NULL));
      if (s->type.t == MACRO_FUNC) {
!         Sym *a = s->e.next;
          fprintf(fp,"(");
          if (a)
              for (;;) {
                  fprintf(fp,"%s", get_tok_str(a->v & ~SYM_FIELD, NULL));
!                 if (!(a = a->e.next))
                      break;
                  fprintf(fp,",");
              }
          fprintf(fp,")");
      }
!     tok_print("", s->b.d);
  }
  
  static void pp_debug_defines(TCCState *s1)
diff -r -N -c a/tccrun.c b/tccrun.c
*** a/tccrun.c	2022-08-18 09:34:36.000000000 +0000
--- b/tccrun.c	2023-02-02 12:28:01.090552970 +0000
***************
*** 1,3 ****
--- 1,4 ----
+ #pragma TenDRA function pointer as pointer allow
  /*
   *  TCC - Tiny C Compiler - Support for -run switch
   *
***************
*** 104,110 ****
  	tcc_error("tccrun: could not map memory");
      ptr_diff = (char*)prx - (char*)ptr;
      close(fd);
!     //printf("map %p %p %p\n", ptr, prx, (void*)ptr_diff);
  }
  #else
      ptr = tcc_malloc(size);
--- 105,111 ----
  	tcc_error("tccrun: could not map memory");
      ptr_diff = (char*)prx - (char*)ptr;
      close(fd);
!     /* //printf("map %p %p %p\n", ptr, prx, (void*)ptr_diff); */
  }
  #else
      ptr = tcc_malloc(size);
***************
*** 139,148 ****
  static void run_cdtors(TCCState *s1, const char *start, const char *end,
                         int argc, char **argv, char **envp)
  {
!     void **a = (void **)get_sym_addr(s1, start, 0, 0);
!     void **b = (void **)get_sym_addr(s1, end, 0, 0);
!     while (a != b)
!         ((void(*)(int, char **, char **))*a++)(argc, argv, envp);
  }
  
  /* launch the compiled program with the given arguments */
--- 140,149 ----
  static void run_cdtors(TCCState *s1, const char *start, const char *end,
                         int argc, char **argv, char **envp)
  {
!    void(**a)(int, char **, char **) = (void(**)(int, char **, char **))get_sym_addr(s1, start, 0, 0);
!    void(**b)(int, char **, char **) = (void(**)(int, char **, char **))get_sym_addr(s1, end, 0, 0);
!    while (a != b)
!        (*(*a++))(argc, argv, envp);
  }
  
  /* launch the compiled program with the given arguments */
***************
*** 159,164 ****
--- 160,166 ----
      extern char **environ;
      char **envp = environ;
  #else
+     extern char **environ;
      char **envp = environ;
  #endif
  
***************
*** 423,429 ****
      }
  }
  #endif
! #endif //ndef CONFIG_TCC_BACKTRACE_ONLY
  /* ------------------------------------------------------------- */
  #ifdef CONFIG_TCC_BACKTRACE
  
--- 425,431 ----
      }
  }
  #endif
! #endif /* //ndef CONFIG_TCC_BACKTRACE_ONLY */
  /* ------------------------------------------------------------- */
  #ifdef CONFIG_TCC_BACKTRACE
  
***************
*** 713,734 ****
          function = NULL;
  	length = 4;
  	size = dwarf_read_4(ln, rc->dwarf_line_end);
! 	if (size == 0xffffffffu) // dwarf 64
  	    length = 8, size = dwarf_read_8(ln, rc->dwarf_line_end);
  	end = ln + size;
  	if (end < ln || end > rc->dwarf_line_end)
  	    break;
  	version = dwarf_read_2(ln, end);
  	if (version >= 5)
! 	    ln += length + 2; // address size, segment selector, prologue Length
  	else
! 	    ln += length; // prologue Length
  	min_insn_length = dwarf_read_1(ln, end);
  	if (version >= 4)
  	    max_ops_per_insn = dwarf_read_1(ln, end);
  	else
  	    max_ops_per_insn = 1;
! 	ln++; // Initial value of 'is_stmt'
  	line_base = dwarf_read_1(ln, end);
  	line_base |= line_base >= 0x80 ? ~0xff : 0;
  	line_range = dwarf_read_1(ln, end);
--- 715,736 ----
          function = NULL;
  	length = 4;
  	size = dwarf_read_4(ln, rc->dwarf_line_end);
! 	if (size == 0xffffffffu) /* // dwarf 64 */
  	    length = 8, size = dwarf_read_8(ln, rc->dwarf_line_end);
  	end = ln + size;
  	if (end < ln || end > rc->dwarf_line_end)
  	    break;
  	version = dwarf_read_2(ln, end);
  	if (version >= 5)
! 	    ln += length + 2; /* // address size, segment selector, prologue Length */
  	else
! 	    ln += length; /* // prologue Length */
  	min_insn_length = dwarf_read_1(ln, end);
  	if (version >= 4)
  	    max_ops_per_insn = dwarf_read_1(ln, end);
  	else
  	    max_ops_per_insn = 1;
! 	ln++; /* // Initial value of 'is_stmt' */
  	line_base = dwarf_read_1(ln, end);
  	line_base |= line_base >= 0x80 ? ~0xff : 0;
  	line_range = dwarf_read_1(ln, end);
***************
*** 813,820 ****
  		    while (dwarf_read_1(ln, end)) {}
  		    dwarf_read_uleb128(&ln, end);
  		}
! 		dwarf_read_uleb128(&ln, end); // time
! 		dwarf_read_uleb128(&ln, end); // size
  	    }
  	}
  	if (filename_size >= 1)
--- 815,822 ----
  		    while (dwarf_read_1(ln, end)) {}
  		    dwarf_read_uleb128(&ln, end);
  		}
! 		dwarf_read_uleb128(&ln, end); /* // time */
! 		dwarf_read_uleb128(&ln, end); /* // size */
  	    }
  	}
  	if (filename_size >= 1)
***************
*** 867,874 ****
  		            while (dwarf_read_1(ln, end)) {}
  		            dwarf_read_uleb128(&ln, end);
  		        }
! 		        dwarf_read_uleb128(&ln, end); // time
! 		        dwarf_read_uleb128(&ln, end); // size
  		        break;
  		    case DW_LNE_hi_user - 1:
  		        function = (char *)cp;
--- 869,876 ----
  		            while (dwarf_read_1(ln, end)) {}
  		            dwarf_read_uleb128(&ln, end);
  		        }
! 		        dwarf_read_uleb128(&ln, end); /* // time */
! 		        dwarf_read_uleb128(&ln, end); /* // size */
  		        break;
  		    case DW_LNE_hi_user - 1:
  		        function = (char *)cp;
***************
*** 1097,1104 ****
      rc->ip = uc->uc_mcontext.arm_pc;
      rc->fp = uc->uc_mcontext.arm_fp;
  #elif defined(__aarch64__) && defined(__APPLE__)
!     // see:
!     // /Library/Developer/CommandLineTools/SDKs/MacOSX11.1.sdk/usr/include/mach/arm/_structs.h
      rc->ip = uc->uc_mcontext->__ss.__pc;
      rc->fp = uc->uc_mcontext->__ss.__fp;
  #elif defined(__aarch64__) && defined(__FreeBSD__)
--- 1099,1106 ----
      rc->ip = uc->uc_mcontext.arm_pc;
      rc->fp = uc->uc_mcontext.arm_fp;
  #elif defined(__aarch64__) && defined(__APPLE__)
!     /* // see: */
!     /* // /Library/Developer/CommandLineTools/SDKs/MacOSX11.1.sdk/usr/include/mach/arm/_structs.h */
      rc->ip = uc->uc_mcontext->__ss.__pc;
      rc->fp = uc->uc_mcontext->__ss.__fp;
  #elif defined(__aarch64__) && defined(__FreeBSD__)
***************
*** 1171,1177 ****
         runtime errors */
      sigemptyset (&sigact.sa_mask);
      sigact.sa_flags = SA_SIGINFO | SA_RESETHAND;
! #if 0//def SIGSTKSZ // this causes signals not to work at all on some (older) linuxes
      sigact.sa_flags |= SA_ONSTACK;
  #endif
      sigact.sa_sigaction = sig_error;
--- 1173,1179 ----
         runtime errors */
      sigemptyset (&sigact.sa_mask);
      sigact.sa_flags = SA_SIGINFO | SA_RESETHAND;
! #if 0/* //def SIGSTKSZ // this causes signals not to work at all on some (older) linuxes */
      sigact.sa_flags |= SA_ONSTACK;
  #endif
      sigact.sa_sigaction = sig_error;
***************
*** 1181,1187 ****
      sigaction(SIGSEGV, &sigact, NULL);
      sigaction(SIGBUS, &sigact, NULL);
      sigaction(SIGABRT, &sigact, NULL);
! #if 0//def SIGSTKSZ
      /* This allows stack overflow to be reported instead of a SEGV */
      {
          stack_t ss;
--- 1183,1189 ----
      sigaction(SIGSEGV, &sigact, NULL);
      sigaction(SIGBUS, &sigact, NULL);
      sigaction(SIGABRT, &sigact, NULL);
! #if 0/* //def SIGSTKSZ */
      /* This allows stack overflow to be reported instead of a SEGV */
      {
          stack_t ss;
***************
*** 1313,1319 ****
  }
  
  #else
! #warning add arch specific rt_get_caller_pc()
  static int rt_get_caller_pc(addr_t *paddr, rt_context *rc, int level)
  {
      return -1;
--- 1315,1321 ----
  }
  
  #else
! /* #warning add arch specific rt_get_caller_pc() */
  static int rt_get_caller_pc(addr_t *paddr, rt_context *rc, int level)
  {
      return -1;
diff -r -N -c a/tcctools.c b/tcctools.c
*** a/tcctools.c	2022-08-18 09:34:36.000000000 +0000
--- b/tcctools.c	2023-02-02 08:46:12.576178770 +0000
***************
*** 30,36 ****
  
  #include "tcc.h"
  
! //#define ARMAG  "!<arch>\n"
  #define ARFMAG "`\n"
  
  typedef struct {
--- 30,36 ----
  
  #include "tcc.h"
  
! /* //#define ARMAG  "!<arch>\n" */
  #define ARFMAG "`\n"
  
  typedef struct {
***************
*** 87,123 ****
      ElfW(Sym) *sym;
      int i, fsize, i_lib, i_obj;
      char *buf, *shstr, *symtab = NULL, *strtab = NULL;
!     int symtabsize = 0;//, strtabsize = 0;
      char *anames = NULL;
      int *afpos = NULL;
      int istrlen, strpos = 0, fpos = 0, funccnt = 0, funcmax, hofs;
      char tfile[260], stmp[20];
      char *file, *name;
      int ret = 2;
!     const char *ops_conflict = "habdioptxN";  // unsupported but destructive if ignored.
      int verbose = 0;
  
!     i_lib = 0; i_obj = 0;  // will hold the index of the lib and first obj
      for (i = 1; i < argc; i++) {
          const char *a = argv[i];
          if (*a == '-' && strstr(a, "."))
!             ret = 1; // -x.y is always invalid (same as gnu ar)
!         if ((*a == '-') || (i == 1 && !strstr(a, "."))) {  // options argument
              if (contains_any(a, ops_conflict))
                  ret = 1;
              if (strstr(a, "v"))
                  verbose = 1;
!         } else {  // lib or obj files: don't abort - keep validating all args.
!             if (!i_lib)  // first file is the lib
                  i_lib = i;
!             else if (!i_obj)  // second file is the first obj
                  i_obj = i;
          }
      }
  
!     if (!i_lib)  // i_obj implies also i_lib.
          ret = 1;
!     i_obj = i_obj ? i_obj : argc;  // An empty archive will be generated if no input file is given
  
      if (ret == 1)
          return ar_usage(ret);
--- 87,123 ----
      ElfW(Sym) *sym;
      int i, fsize, i_lib, i_obj;
      char *buf, *shstr, *symtab = NULL, *strtab = NULL;
!     int symtabsize = 0;/* //, strtabsize = 0; */
      char *anames = NULL;
      int *afpos = NULL;
      int istrlen, strpos = 0, fpos = 0, funccnt = 0, funcmax, hofs;
      char tfile[260], stmp[20];
      char *file, *name;
      int ret = 2;
!     const char *ops_conflict = "habdioptxN";  /* // unsupported but destructive if ignored. */
      int verbose = 0;
  
!     i_lib = 0; i_obj = 0;  /* // will hold the index of the lib and first obj */
      for (i = 1; i < argc; i++) {
          const char *a = argv[i];
          if (*a == '-' && strstr(a, "."))
!             ret = 1; /* // -x.y is always invalid (same as gnu ar) */
!         if ((*a == '-') || (i == 1 && !strstr(a, "."))) {  /* // options argument */
              if (contains_any(a, ops_conflict))
                  ret = 1;
              if (strstr(a, "v"))
                  verbose = 1;
!         } else {  /* // lib or obj files: don't abort - keep validating all args. */
!             if (!i_lib)  /* // first file is the lib */
                  i_lib = i;
!             else if (!i_obj)  /* // second file is the first obj */
                  i_obj = i;
          }
      }
  
!     if (!i_lib)  /* // i_obj implies also i_lib. */
          ret = 1;
!     i_obj = i_obj ? i_obj : argc;  /* // An empty archive will be generated if no input file is given */
  
      if (ret == 1)
          return ar_usage(ret);
***************
*** 136,148 ****
      }
  
      funcmax = 250;
!     afpos = tcc_realloc(NULL, funcmax * sizeof *afpos); // 250 func
      memcpy(&arhdro.ar_mode, "100666", 6);
  
!     // i_obj = first input object file
      while (i_obj < argc)
      {
!         if (*argv[i_obj] == '-') {  // by now, all options start with '-'
              i_obj++;
              continue;
          }
--- 136,148 ----
      }
  
      funcmax = 250;
!     afpos = tcc_realloc(NULL, funcmax * sizeof *afpos); /* // 250 func */
      memcpy(&arhdro.ar_mode, "100666", 6);
  
!     /* // i_obj = first input object file */
      while (i_obj < argc)
      {
!         if (*argv[i_obj] == '-') {  /* // by now, all options start with '-' */
              i_obj++;
              continue;
          }
***************
*** 160,166 ****
          fread(buf, fsize, 1, fi);
          fclose(fi);
  
!         // elf header
          ehdr = (ElfW(Ehdr) *)buf;
          if (ehdr->e_ident[4] != ELFCLASSW)
          {
--- 160,166 ----
          fread(buf, fsize, 1, fi);
          fclose(fi);
  
!         /* // elf header */
          ehdr = (ElfW(Ehdr) *)buf;
          if (ehdr->e_ident[4] != ELFCLASSW)
          {
***************
*** 185,191 ****
                  if (!strcmp(shstr + shdr->sh_name, ".strtab"))
                  {
                      strtab = (char *)(buf + shdr->sh_offset);
!                     //strtabsize = shdr->sh_size;
                  }
              }
          }
--- 185,191 ----
                  if (!strcmp(shstr + shdr->sh_name, ".strtab"))
                  {
                      strtab = (char *)(buf + shdr->sh_offset);
!                     /* //strtabsize = shdr->sh_size; */
                  }
              }
          }
***************
*** 193,199 ****
          if (symtab && symtabsize)
          {
              int nsym = symtabsize / sizeof(ElfW(Sym));
!             //printf("symtab: info size shndx name\n");
              for (i = 1; i < nsym; i++)
              {
                  sym = (ElfW(Sym) *) (symtab + i * sizeof(ElfW(Sym)));
--- 193,199 ----
          if (symtab && symtabsize)
          {
              int nsym = symtabsize / sizeof(ElfW(Sym));
!             /* //printf("symtab: info size shndx name\n"); */
              for (i = 1; i < nsym; i++)
              {
                  sym = (ElfW(Sym) *) (symtab + i * sizeof(ElfW(Sym)));
***************
*** 205,218 ****
                      || sym->st_info == 0x21
                      || sym->st_info == 0x22
                      )) {
!                     //printf("symtab: %2Xh %4Xh %2Xh %s\n", sym->st_info, sym->st_size, sym->st_shndx, strtab + sym->st_name);
                      istrlen = strlen(strtab + sym->st_name)+1;
                      anames = tcc_realloc(anames, strpos+istrlen);
                      strcpy(anames + strpos, strtab + sym->st_name);
                      strpos += istrlen;
                      if (++funccnt >= funcmax) {
                          funcmax += 250;
!                         afpos = tcc_realloc(afpos, funcmax * sizeof *afpos); // 250 func more
                      }
                      afpos[funccnt] = fpos;
                  }
--- 205,218 ----
                      || sym->st_info == 0x21
                      || sym->st_info == 0x22
                      )) {
!                     /* //printf("symtab: %2Xh %4Xh %2Xh %s\n", sym->st_info, sym->st_size, sym->st_shndx, strtab + sym->st_name); */
                      istrlen = strlen(strtab + sym->st_name)+1;
                      anames = tcc_realloc(anames, strpos+istrlen);
                      strcpy(anames + strpos, strtab + sym->st_name);
                      strpos += istrlen;
                      if (++funccnt >= funcmax) {
                          funcmax += 250;
!                         afpos = tcc_realloc(afpos, funcmax * sizeof *afpos); /* // 250 func more */
                      }
                      afpos[funccnt] = fpos;
                  }
***************
*** 239,249 ****
      }
      hofs = 8 + sizeof(arhdr) + strpos + (funccnt+1) * sizeof(int);
      fpos = 0;
!     if ((hofs & 1)) // align
          hofs++, fpos = 1;
!     // write header
      fwrite("!<arch>\n", 8, 1, fh);
!     // create an empty archive
      if (!funccnt) {
          ret = 0;
          goto the_end;
--- 239,249 ----
      }
      hofs = 8 + sizeof(arhdr) + strpos + (funccnt+1) * sizeof(int);
      fpos = 0;
!     if ((hofs & 1)) /* // align */
          hofs++, fpos = 1;
!     /* // write header */
      fwrite("!<arch>\n", 8, 1, fh);
!     /* // create an empty archive */
      if (!funccnt) {
          ret = 0;
          goto the_end;
***************
*** 258,264 ****
      fwrite(anames, strpos, 1, fh);
      if (fpos)
          fwrite("", 1, 1, fh);
!     // write objects
      fseek(fo, 0, SEEK_END);
      fsize = ftell(fo);
      fseek(fo, 0, SEEK_SET);
--- 258,264 ----
      fwrite(anames, strpos, 1, fh);
      if (fpos)
          fwrite("", 1, 1, fh);
!     /* // write objects */
      fseek(fo, 0, SEEK_END);
      fsize = ftell(fo);
      fseek(fo, 0, SEEK_SET);
